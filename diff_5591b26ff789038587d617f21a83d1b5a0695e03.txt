diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..1ac0bca
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,24 @@
+# Gitignore personalizado
+# Binários
+app/*/*
+!app/*/*.h
+!app/*/*.cc
+!app/*/makefile
+
+# Configurações
+*.cfg
+
+# Imagem
+img/*
+!img/makefile
+
+# Arquivos temporários
+*.o
+
+# Ferramentas
+eposcfg
+eposmkbi
+
+# IDEs
+.vscode
+.idea
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..e391a70
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,10 @@
+FROM fedora:40
+
+RUN yum -y update &&  \
+    yum -y install make g++ gcc gdb qemu binutils binutils-x86_64-linux-gnu cross-gcc-common \
+                    gcc-c++-x86_64-linux-gnu nano dev86 bridge-utils libvirt virt-install qemu-kvm && \
+    yum clean all
+
+WORKDIR /app
+
+ENTRYPOINT ["/sbin/init"]
diff --git a/README.md b/README.md
deleted file mode 100644
index 28d7fc1..0000000
--- a/README.md
+++ /dev/null
@@ -1,59 +0,0 @@
-# EPOS
-
-The [Embedded Parallel Operating System (EPOS)](https://epos.lisha.ufsc.br) project aims at automating the development of embedded systems so that developers can concentrate on what really matters: their applications. EPOS relies on the Application-Driven Embedded System Design (ADESD) method to guide the development of both software and hardware components that can be automatically adapted to fulfill the requirements of particular applications. EPOS features a set of tools to support developers in selecting, configuring, and plugging components into its application-specific framework. The combination of methodology, components, frameworks, and tools enable the automatic generation of an application-specific embedded system instances. 
-
-## Getting Started
-
-Check the **Setting up EPOS** section of the [manual](https://epos.lisha.ufsc.br/EPOS+2+User+Guide#Setting_up_EPOS).
-
-### Prerequisites
-
-* **Cross-compilers** for the target architecture you intend to use.
-
-    Fedora packs compilers for x86 that can be installed with ```dnf install binutils-x86_64-linux-gnu gcc-c++-x86_64-linux-gnu``` and ARM compilers that can be installed with: ```dnf install arm-none-eabi-binutils-cs arm-none-eabi-gcc-cs-c++ arm-none-eabi-newlib```.
-
-    On ubuntu 18.04 the x86 packs can be installed with ```apt install binutils-x86-64-linux-gnu```, and ARM compilers can be installed with ```apt install binutils-arm-none-eabi gcc-arm-none-eabi```. Make sure your ubuntu has the ```make``` package already installed.
-
-* **32-bit development libs** (if your development platform is 64-bit)
-
-    For fedora: ```dnf install libc-devel.i686 libstdc++.i686 libstdc++-devel zlib.i686```
-
-    For ubuntu 18.04: ```apt install lib32stdc++6 libc6-i386 libc6-dev-i386 lib32z1 lib32ncurses5 libbz2-1.0:i386 gcc-multilib g++-multilib```
-
-* **Intel 8086** tools (to compile the bootstrap, only if you intend to use x86)
-
-    For fedora: ```dnf install dev86```
-
-    For ubuntu: ```apt install bin86```
-
-### Installing
-
-Simply extract the tarball or clone the repository in a convenient location for you. EPOS is fully self-contained. 
-
-### Building
-
-Go into the directory where you extracted EPOS and issue a ```make all``` to have instances of EPOS built for each of the applications in the ```app``` directory. 
-
-You can also built for specific applications using ```make APPLICATION=<app>```, where \<app\> is a subdir of ```app```.
-
-### Running
-
-After building an application-oriented instance of EPOS, you can run the application with the tailored EPOS on QEMU using: ```make APPLICATION=<app> run```
-
-## Contributing
-
-Please read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our code of conduct, and the process for submitting pull requests to us.
-
-## Versioning
-
-We use [SemVer](http://semver.org/) for versioning. For the versions available, see the [tags on this repository](https://gitlab.lisha.ufsc.br/osdi/teaching2/tags). 
-
-## Authors
-
-* **Antônio Augusto Fröhlich** - *Initial work* - [Guto](https://lisha.ufsc.br/Guto)
-
-See also the list of [contributors](https://epos.lisha.ufsc.br/EPOS+Developers) who participated in this project.
-
-## License
-
-This project is licensed under the GPL 2.0 License - see the [LICENSE](LICENSE) file for details
diff --git a/app/aperiodic/aperiodic.cc b/app/aperiodic/aperiodic.cc
new file mode 100644
index 0000000..be645ba
--- /dev/null
+++ b/app/aperiodic/aperiodic.cc
@@ -0,0 +1,54 @@
+#include <utility/ostream.h>
+#include <process.h>
+#include <time.h>
+#include <real-time.h>
+#include <utility/random.h>
+using namespace EPOS;
+OStream cout;
+const int N_THREADS_A = 128; // Aperiodic
+
+int isPrime(const int n) {
+  bool is_prime = true;
+  // 0 and 1 are not prime numbers
+  if (n == 0 || n == 1) {
+    is_prime = false;
+  }
+  // loop to check if n is prime
+  for (int i = 2; i <= n/2; ++i) {
+    if (n % i == 0) {
+      is_prime = false;
+      break;
+    }
+  }
+  if (is_prime)
+    cout << " found a prime number " << n << endl;
+  return 0;
+}
+
+int work(int n)
+{
+    cout << "CPU: " << CPU::id() << " WORK: Hello world! " << n << endl;
+    for (int i = 0; i < 1000; i++)
+    {
+        isPrime(i);
+    }
+    cout << "CPU: " << CPU::id() << " WORK: Bye world! " << n << endl;
+    return 0;
+}
+
+int main()
+{
+    cout << "MAIN: Hello world!" << endl;
+    const Thread::Criterion CRITS[3]{Thread::LOW, Thread::NORMAL, Thread::HIGH};
+    Thread *ts[N_THREADS_A];
+    for (int i = 0; i < N_THREADS_A; i++)
+    {
+        // Thread aperiódica
+        ts[i] = new Thread(Thread::Configuration(Thread::READY, CRITS[i % 3]), &work, i);
+    }
+    for (int i = 0; i < N_THREADS_A; i++) {
+        ts[i]->join();
+    }
+    cout << "System is going down!" << endl;
+    return 0;
+}
\ No newline at end of file
diff --git a/app/aperiodic/aperiodic_traits.h b/app/aperiodic/aperiodic_traits.h
new file mode 100644
index 0000000..d35d37a
--- /dev/null
+++ b/app/aperiodic/aperiodic_traits.h
@@ -0,0 +1,198 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template <>
+struct Traits<Build> : public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int SMOD = LIBRARY;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = 4;
+    static const unsigned int NETWORKING = STANDALONE;
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool debugged = true;
+    static const bool monitored = true;
+    static const bool hysterically_debugged = false;
+};
+
+// Utilities
+template <>
+struct Traits<Debug> : public Traits<Build>
+{
+    static const bool error = true;
+    static const bool warning = false;
+    static const bool info = false;
+    static const bool trace = false;
+};
+
+template <>
+struct Traits<EAMQ> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<GEAMQ> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<PEAMQ> : public Traits<Build>
+{
+    static const bool debugged = true;
+};
+
+template <>
+struct Traits<Lists> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Spin> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Heaps> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Observers> : public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+// System Parts (mostly to fine control debugging)
+template <>
+struct Traits<Boot> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Setup> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Init> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Framework> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Aspect> : public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+// API Components
+template <>
+struct Traits<Application> : public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template <>
+struct Traits<System> : public Traits<Build>
+{
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1) || (CPUS > 1);
+    static const bool multicore = multithread && (CPUS > 1);
+    static const bool multiheap = false;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000;  // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + Traits<Build>::CPUS) * Traits<Application>::STACK_SIZE;
+
+    static const unsigned int RUN_TO_HALT = true;
+};
+
+template <>
+struct Traits<Thread> : public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+    static const int priority_inversion_protocol = NONE;
+
+
+    typedef IF<(CPUS > 1), PEAMQ, EAMQ>::Result Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Scheduler<Thread>> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Synchronizer> : public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Alarm> : public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Address_Space> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Segment> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+__END_SYS
+
+#endif
diff --git a/app/concurrent_philosophers_dinner/makefile b/app/aperiodic/makefile
similarity index 100%
rename from app/concurrent_philosophers_dinner/makefile
rename to app/aperiodic/makefile
diff --git a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner.cc b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner.cc
deleted file mode 100644
index 2c2ad30..0000000
--- a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner.cc
+++ /dev/null
@@ -1,135 +0,0 @@
-// EPOS Scheduler Test Program
-
-#include <machine.h>
-#include <time.h>
-#include <synchronizer.h>
-#include <process.h>
-
-using namespace EPOS;
-
-const int iterations = 10;
-
-Semaphore table;
-
-Thread * phil[5];
-Semaphore * chopstick[5];
-
-OStream cout;
-
-int philosopher(int n, int l, int c);
-void think(unsigned long long n);
-void eat(unsigned long long n);
-unsigned long long busy_wait(unsigned long long n);
-
-int main()
-{
-    table.p();
-    Display::clear();
-    Display::position(0, 0);
-    cout << "The Philosopher's Dinner:" << endl;
-
-    for(int i = 0; i < 5; i++)
-        chopstick[i] = new Semaphore;
-
-    phil[0] = new Thread(&philosopher, 0,  5, 30);
-    phil[1] = new Thread(&philosopher, 1, 10, 44);
-    phil[2] = new Thread(&philosopher, 2, 16, 39);
-    phil[3] = new Thread(&philosopher, 3, 16, 21);
-    phil[4] = new Thread(&philosopher, 4, 10, 17);
-
-    cout << "Philosophers are alive and hungry!" << endl;
-
-    Display::position(7, 44);
-    cout << '/';
-    Display::position(13, 44);
-    cout << '\\';
-    Display::position(16, 35);
-    cout << '|';
-    Display::position(13, 27);
-    cout << '/';
-    Display::position(7, 27);
-    cout << '\\';
-    Display::position(19, 0);
-
-    cout << "The dinner is served ..." << endl;
-    table.v();
-
-    for(int i = 0; i < 5; i++) {
-        int ret = phil[i]->join();
-        table.p();
-        Display::position(20 + i, 0);
-        cout << "Philosopher " << i << " ate " << ret << " times " << endl;
-        table.v();
-    }
-
-    for(int i = 0; i < 5; i++)
-        delete chopstick[i];
-    for(int i = 0; i < 5; i++)
-        delete phil[i];
-
-    cout << "The end!" << endl;
-
-    return 0;
-}
-
-int philosopher(int n, int l, int c)
-{
-    int first = (n < 4)? n : 0;
-    int second = (n < 4)? n + 1 : 4;
-
-    for(int i = iterations; i > 0; i--) {
-
-        table.p();
-        Display::position(l, c);
-        cout << "thinking[" << CPU::id() << "]";
-        table.v();
-
-        think(1000000);
-
-        table.p();
-        Display::position(l, c);
-        cout << "  hungry[" << CPU::id() << "]";
-        table.v();
-
-        chopstick[first]->p();   // get first chopstick
-        chopstick[second]->p();  // get second chopstick
-
-        table.p();
-        Display::position(l, c);
-        cout << " eating[" << CPU::id() << "] ";
-        table.v();
-
-        eat(500000);
-
-        table.p();
-        Display::position(l, c);
-        cout << "    sate[" << CPU::id() << "]";
-        table.v();
-
-        chopstick[first]->v();   // release first chopstick
-        chopstick[second]->v();  // release second chopstick
-    }
-
-    table.p();
-    Display::position(l, c);
-    cout << "  done[" << CPU::id() << "]  ";
-    table.v();
-
-    return iterations;
-}
-
-void eat(unsigned long long n) {
-    busy_wait(n);
-}
-
-void think(unsigned long long n) {
-    busy_wait(n);
-}
-
-unsigned long long busy_wait(unsigned long long n)
-{
-    volatile unsigned long long v;
-    for(unsigned long long int j = 0; j < 20 * n; j++)
-        v &= 2 ^ j;
-    return v;
-}
diff --git a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h b/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
deleted file mode 100644
index 68dbb09..0000000
--- a/app/concurrent_philosophers_dinner/concurrent_philosophers_dinner_traits.h
+++ /dev/null
@@ -1,146 +0,0 @@
-#ifndef __traits_h
-#define __traits_h
-
-#include <system/config.h>
-
-__BEGIN_SYS
-
-// Build
-template<> struct Traits<Build>: public Traits_Tokens
-{
-    // Basic configuration
-    static const unsigned int SMOD = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
-    static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
-    static const unsigned int CPUS = 1;
-    static const unsigned int NETWORKING = STANDALONE;
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
-
-    // Default flags
-    static const bool enabled = true;
-    static const bool debugged = true;
-    static const bool hysterically_debugged = false;
-};
-
-
-// Utilities
-template<> struct Traits<Debug>: public Traits<Build>
-{
-    static const bool error   = true;
-    static const bool warning = true;
-    static const bool info    = false;
-    static const bool trace   = false;
-};
-
-template<> struct Traits<Lists>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-template<> struct Traits<Spin>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-template<> struct Traits<Heaps>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-template<> struct Traits<Observers>: public Traits<Build>
-{
-    // Some observed objects are created before initializing the Display
-    // Enabling debug may cause trouble in some Machines
-    static const bool debugged = false;
-};
-
-
-// System Parts (mostly to fine control debugging)
-template<> struct Traits<Boot>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Setup>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Init>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Framework>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Aspect>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-
-__END_SYS
-
-// Mediators
-#include __ARCHITECTURE_TRAITS_H
-#include __MACHINE_TRAITS_H
-
-__BEGIN_SYS
-
-
-// API Components
-template<> struct Traits<Application>: public Traits<Build>
-{
-    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
-    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
-    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
-};
-
-template<> struct Traits<System>: public Traits<Build>
-{
-    static const bool multithread = (Traits<Application>::MAX_THREADS > 1) || (CPUS > 1);
-    static const bool multicore = multithread && (CPUS > 1);
-    static const bool multiheap = Traits<Scratchpad>::enabled;
-
-    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
-    static const unsigned int DUTY_CYCLE = 1000000; // ppm
-
-    static const bool reboot = true;
-
-    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
-    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + Traits<Build>::CPUS) * Traits<Application>::STACK_SIZE;
-};
-
-template<> struct Traits<Thread>: public Traits<Build>
-{
-    static const bool enabled = Traits<System>::multithread;
-    static const bool smp = Traits<System>::multicore;
-    static const bool trace_idle = hysterically_debugged;
-    static const bool simulate_capacity = false;
-
-    typedef IF<(CPUS > 1), GRR, RR>::Result Criterion;
-    static const unsigned int QUANTUM = 10000; // us
-};
-
-template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
-{
-    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
-};
-
-template<> struct Traits<Synchronizer>: public Traits<Build>
-{
-    static const bool enabled = Traits<System>::multithread;
-};
-
-template<> struct Traits<Alarm>: public Traits<Build>
-{
-    static const bool visible = hysterically_debugged;
-};
-
-template<> struct Traits<Address_Space>: public Traits<Build> {};
-
-template<> struct Traits<Segment>: public Traits<Build> {};
-
-__END_SYS
-
-#endif
diff --git a/app/hello/hello.cc b/app/hello/hello.cc
deleted file mode 100644
index 40c7c05..0000000
--- a/app/hello/hello.cc
+++ /dev/null
@@ -1,12 +0,0 @@
-#include <utility/ostream.h>
-
-using namespace EPOS;
-
-OStream cout;
-
-int main()
-{
-    cout << "Hello world!" << endl;
-
-    return 0;
-}
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
deleted file mode 100644
index 01a8463..0000000
--- a/app/hello/hello_traits.h
+++ /dev/null
@@ -1,149 +0,0 @@
-#ifndef __traits_h
-#define __traits_h
-
-#include <system/config.h>
-
-__BEGIN_SYS
-
-// Build
-template<> struct Traits<Build>: public Traits_Tokens
-{
-    // Basic configuration
-    static const unsigned int SMOD = LIBRARY;
-    static const unsigned int ARCHITECTURE = IA32;
-    static const unsigned int MACHINE = PC;
-    static const unsigned int MODEL = Legacy_PC;
-    static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
-    static const unsigned int NETWORKING = STANDALONE;
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
-
-    // Default flags
-    static const bool enabled = true;
-    static const bool monitored = true;
-    static const bool debugged = true;
-    static const bool hysterically_debugged = false;
-};
-
-
-// Utilities
-template<> struct Traits<Debug>: public Traits<Build>
-{
-    static const bool error   = true;
-    static const bool warning = true;
-    static const bool info    = false;
-    static const bool trace   = false;
-};
-
-template<> struct Traits<Lists>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-template<> struct Traits<Spin>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-template<> struct Traits<Heaps>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-template<> struct Traits<Observers>: public Traits<Build>
-{
-    // Some observed objects are created before initializing the Display
-    // Enabling debug may cause trouble in some Machines
-    static const bool debugged = false;
-};
-
-
-// System Parts (mostly to fine control debugging)
-template<> struct Traits<Boot>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Setup>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Init>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Framework>: public Traits<Build>
-{
-};
-
-template<> struct Traits<Aspect>: public Traits<Build>
-{
-    static const bool debugged = hysterically_debugged;
-};
-
-
-__END_SYS
-
-// Mediators
-#include __ARCHITECTURE_TRAITS_H
-#include __MACHINE_TRAITS_H
-
-__BEGIN_SYS
-
-
-// API Components
-template<> struct Traits<Application>: public Traits<Build>
-{
-    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
-    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
-    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
-};
-
-template<> struct Traits<System>: public Traits<Build>
-{
-    static const bool multithread = (Traits<Application>::MAX_THREADS > 1) || (CPUS > 1);
-    static const bool multicore = multithread && (CPUS > 1);
-    static const bool multiheap = Traits<Scratchpad>::enabled;
-
-    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
-    static const unsigned int DUTY_CYCLE = 1000000; // ppm
-
-    static const bool reboot = true;
-
-    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
-    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + Traits<Build>::CPUS) * Traits<Application>::STACK_SIZE;
-};
-
-template<> struct Traits<Thread>: public Traits<Build>
-{
-    static const bool enabled = Traits<System>::multithread;
-    static const bool smp = Traits<System>::multicore;
-    static const bool trace_idle = hysterically_debugged;
-    static const bool simulate_capacity = false;
-    static const int priority_inversion_protocol = NONE;
-
-
-    typedef IF<(CPUS > 1), Fixed_CPU, Priority>::Result Criterion;
-    static const unsigned int QUANTUM = 10000; // us
-};
-
-template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
-{
-    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
-};
-
-template<> struct Traits<Synchronizer>: public Traits<Build>
-{
-    static const bool enabled = Traits<System>::multithread;
-};
-
-template<> struct Traits<Alarm>: public Traits<Build>
-{
-    static const bool visible = hysterically_debugged;
-};
-
-template<> struct Traits<Address_Space>: public Traits<Build> {};
-
-template<> struct Traits<Segment>: public Traits<Build> {};
-
-__END_SYS
-
-#endif
diff --git a/app/hello/makefile b/app/p4/makefile
similarity index 100%
rename from app/hello/makefile
rename to app/p4/makefile
diff --git a/app/p4/p4.cc b/app/p4/p4.cc
new file mode 100644
index 0000000..00c90fd
--- /dev/null
+++ b/app/p4/p4.cc
@@ -0,0 +1,63 @@
+#include <utility/ostream.h>
+#include <process.h>
+#include <time.h>
+#include <real-time.h>
+#include <utility/random.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+int bruh(int n)
+{
+    cout << "CPU: " << CPU::id() << " bruh - " << n << endl;
+    Alarm::delay(500000 + (int(Random::random()) % 10000));
+    return 0;
+}
+
+int poggers(int n)
+{
+    do {
+        cout << "CPU: " << CPU::id() << " poggers - " << n << endl;
+        Alarm::delay(1000000 + (int(Random::random()) % 10000));
+    } while (Periodic_Thread::wait_next());
+    return 0;
+}
+
+int main()
+{
+    cout << "MAIN: Hello world!" << endl;
+
+    const int N_THREADS_A = 12; // Aperiodic
+    const int N_THREADS_P = 12; // Periodic
+
+    const Thread::Criterion CRITS[3]{Thread::LOW, Thread::NORMAL, Thread::HIGH};
+
+
+    Thread *ts[N_THREADS_A + N_THREADS_P];
+
+    for (int i = 0; i < N_THREADS_A; i++)
+    {
+        // Thread aperiódica
+        ts[i] = new Thread(Thread::Configuration(Thread::READY, CRITS[i % 3]), &bruh, i);
+    }
+
+    for (int i = N_THREADS_A; i < N_THREADS_P + N_THREADS_A; i++)
+    {
+        // Thread periodic
+        auto conf = Periodic_Thread::Configuration(
+            500000 + (int(Random::random()) % 10000),        // periodo
+            120000 + (int(Random::random()) % 24000),          // deadline
+            Periodic_Thread::UNKNOWN,
+            Periodic_Thread::NOW,
+            2
+        );
+        ts[i] = new Periodic_Thread(conf, &poggers, i);
+    }
+
+    for (int i = 0; i < N_THREADS_A + N_THREADS_P; i++) {
+        ts[i]->join();
+    }
+
+    return 0;
+}
diff --git a/app/p4/p4_traits.h b/app/p4/p4_traits.h
new file mode 100644
index 0000000..87947f7
--- /dev/null
+++ b/app/p4/p4_traits.h
@@ -0,0 +1,205 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template <>
+struct Traits<Build> : public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int SMOD = LIBRARY;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = 4;
+    static const unsigned int NETWORKING = STANDALONE;
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+};
+
+// Utilities
+template <>
+struct Traits<Debug> : public Traits<Build>
+{
+    static const bool error = true;
+    static const bool warning = false;
+    static const bool info = false;
+    static const bool trace = false;
+};
+
+template <>
+struct Traits<AAA> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<PEAMQ> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<EAMQ> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<GEAMQ> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Lists> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Spin> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Heaps> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Observers> : public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+// System Parts (mostly to fine control debugging)
+template <>
+struct Traits<Boot> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Setup> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Init> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Framework> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Aspect> : public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+// API Components
+template <>
+struct Traits<Application> : public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template <>
+struct Traits<System> : public Traits<Build>
+{
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1) || (CPUS > 1);
+    static const bool multicore = multithread && (CPUS > 1);
+    static const bool multiheap = false;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000;  // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + Traits<Build>::CPUS) * Traits<Application>::STACK_SIZE;
+
+    static const unsigned int RUN_TO_HALT = true;
+
+};
+
+template <>
+struct Traits<Thread> : public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+    static const int priority_inversion_protocol = NONE;
+
+
+    typedef IF<(CPUS > 1), PEAMQ, EAMQ>::Result Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Scheduler<Thread>> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Synchronizer> : public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Alarm> : public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Address_Space> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Segment> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+__END_SYS
+
+#endif
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 23c561a..b101b37 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int SMOD = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
-    static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
     static const unsigned int CPUS = (MODEL == Legacy_PC) ? 8 : ((MODEL == SiFive_U) || (MODEL == Raspberry_Pi3)) ? 4 : ((MODEL == Realview_PBX) || (MODEL == Zynq)) ? 2 : 1;
     static const unsigned int NETWORKING = STANDALONE;
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
@@ -20,6 +20,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     // Default flags
     static const bool enabled = true;
     static const bool debugged = true;
+    static const bool monitored = true;
     static const bool hysterically_debugged = false;
 };
 
@@ -28,7 +29,7 @@ template<> struct Traits<Build>: public Traits_Tokens
 template<> struct Traits<Debug>: public Traits<Build>
 {
     static const bool error   = true;
-    static const bool warning = true;
+    static const bool warning = false;
     static const bool info    = false;
     static const bool trace   = false;
 };
@@ -100,7 +101,7 @@ template<> struct Traits<System>: public Traits<Build>
 {
     static const bool multithread = (Traits<Application>::MAX_THREADS > 1) || (CPUS > 1);
     static const bool multicore = multithread && (CPUS > 1);
-    static const bool multiheap = Traits<Scratchpad>::enabled;
+    static const bool multiheap = false;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
@@ -109,6 +110,8 @@ template<> struct Traits<System>: public Traits<Build>
 
     static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
     static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + Traits<Build>::CPUS) * Traits<Application>::STACK_SIZE;
+
+    static const unsigned int RUN_TO_HALT = true;
 };
 
 template<> struct Traits<Thread>: public Traits<Build>
@@ -119,7 +122,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const int priority_inversion_protocol = NONE;
 
-    typedef IF<(CPUS > 1), GRR, RR>::Result Criterion;
+    typedef IF<(CPUS > 1), PEAMQ, EAMQ>::Result Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/primes/makefile b/app/primes/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/primes/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/primes/primes.cc b/app/primes/primes.cc
new file mode 100644
index 0000000..c11312a
--- /dev/null
+++ b/app/primes/primes.cc
@@ -0,0 +1,103 @@
+#include <utility/ostream.h>
+#include <process.h>
+#include <time.h>
+#include <real-time.h>
+#include <utility/random.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+const int N_THREADS_A = 16; // Aperiodic
+const int SEARCH_N = 1000;
+
+int primes_found = 0;
+Semaphore m;
+
+struct aperiodic_test
+{
+  int i;
+  int begin;
+  int end;
+
+  aperiodic_test(int i, int begin, int end) : i(i), begin(begin), end(end) {}
+};
+
+
+bool isPrime(const int n) {
+
+  // 0 and 1 are not prime numbers
+  if (n == 1) {
+    return false;
+  }
+
+  // loop to check if n is prime
+  for (int i = 2; i*i <= n; i++) {
+    if (n % i == 0) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+
+int work(aperiodic_test *struct_test)
+{
+    int begin = struct_test->begin;
+    int end = struct_test->end;
+
+    int found = 0;
+    for (int i = begin; i <= end; i++)
+    {
+        found += int(isPrime(i));
+    }
+
+    if (found) {
+      m.p();
+      primes_found += found;
+      m.v();
+    }
+
+    // cout << "WORK " << t << ": Bye! " << "I found " << found << " primes!" << endl;
+    return 0;
+}
+
+
+int main()
+{
+    cout << "MAIN: Hello world!" << endl;
+    cout << "MAIN: Searching number of primes in between 0 - " << SEARCH_N << "\n" << endl;
+
+    const Thread::Criterion CRITS[3]{Thread::LOW, Thread::NORMAL, Thread::HIGH};
+
+
+    Thread *ts[N_THREADS_A];
+    int search_range = (SEARCH_N + (N_THREADS_A - 1)) / N_THREADS_A;
+    int start = 1;
+
+    int i = 0;
+    for (; i < N_THREADS_A; i++)
+    {
+        if (start >= SEARCH_N) break;
+
+        int end = (start + search_range) < SEARCH_N 
+                      ? start + search_range
+                      : SEARCH_N;
+        
+        aperiodic_test *work_struct = new aperiodic_test(i, start, end);
+        cout << "WORK " << i << " will search " << start << " - " << end << endl;
+        auto conf = Thread::Configuration(Thread::READY, CRITS[i % 3]);
+        ts[i] = new Thread(conf, &work, work_struct);
+        start += search_range + 1;
+    }
+
+    for (int j = 0; j < i; j++) {
+        ts[j]->join();
+    }
+
+    cout << "\nMAIN: We found " << primes_found << " prime numbers!" << endl;
+    cout << "MAIN: Test is going down!" << endl;
+
+    return 0;
+}
diff --git a/app/primes/primes_traits.h b/app/primes/primes_traits.h
new file mode 100644
index 0000000..d35d37a
--- /dev/null
+++ b/app/primes/primes_traits.h
@@ -0,0 +1,198 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template <>
+struct Traits<Build> : public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int SMOD = LIBRARY;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = 4;
+    static const unsigned int NETWORKING = STANDALONE;
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool debugged = true;
+    static const bool monitored = true;
+    static const bool hysterically_debugged = false;
+};
+
+// Utilities
+template <>
+struct Traits<Debug> : public Traits<Build>
+{
+    static const bool error = true;
+    static const bool warning = false;
+    static const bool info = false;
+    static const bool trace = false;
+};
+
+template <>
+struct Traits<EAMQ> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<GEAMQ> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<PEAMQ> : public Traits<Build>
+{
+    static const bool debugged = true;
+};
+
+template <>
+struct Traits<Lists> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Spin> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Heaps> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Observers> : public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+// System Parts (mostly to fine control debugging)
+template <>
+struct Traits<Boot> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Setup> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Init> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Framework> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Aspect> : public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+// API Components
+template <>
+struct Traits<Application> : public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template <>
+struct Traits<System> : public Traits<Build>
+{
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1) || (CPUS > 1);
+    static const bool multicore = multithread && (CPUS > 1);
+    static const bool multiheap = false;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000;  // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + Traits<Build>::CPUS) * Traits<Application>::STACK_SIZE;
+
+    static const unsigned int RUN_TO_HALT = true;
+};
+
+template <>
+struct Traits<Thread> : public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+    static const int priority_inversion_protocol = NONE;
+
+
+    typedef IF<(CPUS > 1), PEAMQ, EAMQ>::Result Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Scheduler<Thread>> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Synchronizer> : public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Alarm> : public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Address_Space> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+template <>
+struct Traits<Segment> : public Traits<Build>
+{
+    static const bool debugged = false;
+};
+
+__END_SYS
+
+#endif
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index a070563..27a733f 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -10,15 +10,16 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int SMOD = LIBRARY;
-    static const unsigned int ARCHITECTURE = RV64;
-    static const unsigned int MACHINE = RISCV;
-    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
     static const unsigned int CPUS = ((MODEL == Legacy_PC) || (MODEL == Raspberry_Pi3) || (MODEL == Realview_PBX) || (MODEL == Zynq) || (MODEL == SiFive_U)) ? 2 : 1;
     static const unsigned int NETWORKING = STANDALONE;
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
+    static const bool monitored = true;
     static const bool debugged = true;
     static const bool hysterically_debugged = false;
 };
@@ -27,8 +28,8 @@ template<> struct Traits<Build>: public Traits_Tokens
 // Utilities
 template<> struct Traits<Debug>: public Traits<Build>
 {
-    static const bool error   = true;
-    static const bool warning = true;
+    static const bool error   = false;
+    static const bool warning = false;
     static const bool info    = false;
     static const bool trace   = false;
 };
@@ -100,7 +101,7 @@ template<> struct Traits<System>: public Traits<Build>
 {
     static const bool multithread = (Traits<Application>::MAX_THREADS > 1) || (CPUS > 1);
     static const bool multicore = multithread && (CPUS > 1);
-    static const bool multiheap = Traits<Scratchpad>::enabled;
+    static const bool multiheap = false;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
@@ -109,6 +110,8 @@ template<> struct Traits<System>: public Traits<Build>
 
     static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
     static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + Traits<Build>::CPUS) * Traits<Application>::STACK_SIZE;
+
+    static const unsigned int RUN_TO_HALT = true;
 };
 
 template<> struct Traits<Thread>: public Traits<Build>
@@ -119,7 +122,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool simulate_capacity = false;
     static const int priority_inversion_protocol = NONE;
 
-    typedef IF<(CPUS > 1), Fixed_CPU, FCFS>::Result Criterion;
+    typedef IF<(CPUS > 1), PEAMQ, EAMQ>::Result Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/diff_5591b26ff789038587d617f21a83d1b5a0695e03.txt b/diff_5591b26ff789038587d617f21a83d1b5a0695e03.txt
new file mode 100644
index 0000000..ffb44d7
diff --git a/include/architecture/ia32/ia32_cpu.h b/include/architecture/ia32/ia32_cpu.h
index 684c90c..9050b99 100644
--- a/include/architecture/ia32/ia32_cpu.h
+++ b/include/architecture/ia32/ia32_cpu.h
@@ -411,7 +411,12 @@ public:
 
     template<typename T>
     static T cas(volatile T & value, T compare, T replacement) {
-        ASM("lock cmpxchgl %2, %3\n" : "=a"(compare) : "a"(compare), "r"(replacement), "m"(value) : "memory");
+        asm volatile (
+            "lock cmpxchgl %2, %1"
+            : "=A"(compare), "+m"(value)
+            : "r"(replacement), "0"(compare)
+            : "memory"
+        );
         return compare;
     }
 
diff --git a/include/machine/timer.h b/include/machine/timer.h
index a27b151..506d422 100644
--- a/include/machine/timer.h
+++ b/include/machine/timer.h
@@ -43,6 +43,11 @@ public:
     static Microsecond period(Hertz frequency) { return Microsecond(1000000) / Microsecond(frequency); }
     static Microsecond time(Tick ticks, Hertz frequency) { return Microsecond(ticks) * period(frequency); }
     static Tick ticks(Microsecond time, Hertz frequency) { return (time + period(frequency) / 2) / period(frequency); }
+
+    static Microsecond sim(Microsecond timef1, Hertz f1, Hertz f2) {
+        Microsecond t = (static_cast<long long>(timef1) * (static_cast<long long>(f1) * 100ULL / static_cast<long long>(f2))) / 100ULL;
+        return t;
+    }
 };
 
 __END_SYS
diff --git a/include/process.h b/include/process.h
index 9ae7dc7..a93e13d 100644
--- a/include/process.h
+++ b/include/process.h
@@ -18,12 +18,14 @@ __BEGIN_SYS
 
 class Thread
 {
-    friend class Init_End;                      // context->load()
-    friend class Init_System;                   // for init() on CPU != 0
-    friend class Scheduler<Thread>;             // for link()
-    friend class Synchronizer_Common;           // for lock() and sleep()
-    friend class Alarm;                         // for lock()
-    friend class System;                        // for init()
+    friend class Init_End;              // context->load()
+    friend class Init_System;           // for init() on CPU != 0
+    friend class Scheduler<Thread>;     // for link()
+    friend class Synchronizer_Common;   // for lock() and sleep()
+    friend class Alarm;                 // for lock()
+    friend class System;                // for init()
+    friend class EAMQ;                  // for handle()
+    friend class GEAMQ;                 // for handle()
     friend class IC;                            // for link() for priority ceiling
     friend volatile unsigned long ::_running(); // for running()
 
@@ -63,7 +65,7 @@ public:
 
     // Thread Configuration
     struct Configuration {
-        Configuration(State s = READY, Criterion c = NORMAL, unsigned int ss = STACK_SIZE)
+        Configuration(State s = READY, Criterion c = NORMAL, unsigned int ss = STACK_SIZE, unsigned int d = 10)
         : state(s), criterion(c), stack_size(ss) {}
 
         State state;
@@ -94,16 +96,61 @@ public:
     void resume();
 
     static Thread * volatile self() { return running(); }
+    static Scheduler<Thread> * volatile scheduler() { return &_scheduler; }
     static void yield();
     static void exit(int status = 0);
 
+    // for_all_behind() is used to update the rank of all threads behind the current one
+    // the first time it is called is when a thread is inserted in the scheduler
+    // but it can be called again if other threads changes their queue
+    void for_all_behind(Criterion::Event event) {
+        this->criterion().is_recent_insertion(true);
+   
+        for (Queue::Element * behind = _link.next(); behind != nullptr;)
+        {
+            // if finds a aperiodic thread, stop
+            if (!behind->object()->criterion().periodic()) break;
+
+            // next element to be evaluated
+            Queue::Element * next = behind->next();
+
+            // throws event to the thread
+            behind->object()->criterion().handle(event);
+
+            // remove the thread from the scheduler
+            _scheduler.remove(behind->object());
+
+            // recalculates the rank of the thread
+            behind->object()->criterion().rank_eamq();
+
+            // insert thread in new position (or in the old one)
+            _scheduler.insert(behind->object());
+
+            // if the thread has changed its queue, it is necessary to check the new previous ones
+            if (this->criterion().queue_eamq() != behind->object()->criterion().queue_eamq()) {
+                behind->object()->for_all_behind(event);
+            }
+
+            behind = next;
+        }
+    }
+    alignas (int) static bool _not_booting;
+
 protected:
     void constructor_prologue(unsigned int stack_size);
     void constructor_epilogue(Log_Addr entry, unsigned int stack_size);
 
     Queue::Element * link() { return &_link; }
 
-    static Thread * volatile running() { return _not_booting ? _scheduler.chosen() : reinterpret_cast<Thread * volatile>(CPU::id() + 1); }
+    static Thread * volatile running() { 
+        if (_not_booting) {
+            // db<PEAMQ>(WRN) << "AAAAAAAAA Thread::running() => " << _scheduler.chosen() << endl;
+            return _scheduler.chosen();
+        } else {
+            //db<GEAMQ>(WRN) << "BBBBBBBBB NOT BOOTING!! " << reinterpret_cast<Thread * volatile>(CPU::id() + 1)<< endl;
+            return reinterpret_cast<Thread * volatile>(CPU::id() + 1);
+        }
+    }
 
     static void lock() {
         CPU::int_disable();
@@ -153,7 +200,6 @@ protected:
     Thread * volatile _joining;
     Queue::Element _link;
 
-    alignas (int) static bool _not_booting;
     static volatile unsigned int _thread_count;
     static Scheduler_Timer * _timer;
     static Scheduler<Thread> _scheduler;
diff --git a/include/real-time.h b/include/real-time.h
index fd8e751..e9d570d 100644
--- a/include/real-time.h
+++ b/include/real-time.h
@@ -95,12 +95,10 @@ public:
     static volatile bool wait_next() {
         Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
 
-        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
-
         t->criterion().handle(Criterion::JOB_FINISH);
 
-        if(t->_alarm.times())
-            t->_semaphore.p();
+        if(t->_alarm.times()) {
+            t->_semaphore.p();}
 
         return t->_alarm.times();
     }
diff --git a/include/scheduler.h b/include/scheduler.h
index fea2c9d..7b24257 100644
--- a/include/scheduler.h
+++ b/include/scheduler.h
@@ -26,48 +26,53 @@ protected:
 
 public:
     // Priorities
-    enum : int {
+    enum : int
+    {
         CEILING = -1000,
-        MAIN    = -1,
-        HIGH    = 0,
-        NORMAL  = (unsigned(1) << (sizeof(int) * 8 - 3)) - 1,
-        LOW     = (unsigned(1) << (sizeof(int) * 8 - 2)) - 1,
-        IDLE    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
+        MAIN = -1,
+        HIGH = 0,
+        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 3)) - 1,
+        LOW = (unsigned(1) << (sizeof(int) * 8 - 2)) - 1,
+        IDLE = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
     };
 
     // Constructor helpers
-    enum : unsigned int {
-        SAME        = 0,
-        NOW         = 0,
-        UNKNOWN     = 0,
-        ANY         = -1U
+    enum : unsigned int
+    {
+        SAME = 0,
+        NOW = 0,
+        UNKNOWN = 0,
+        ANY = -1U
     };
 
     // Policy types
-    enum : int {
-        PERIODIC    = HIGH,
-        SPORADIC    = NORMAL,
-        APERIODIC   = LOW
+    enum : int
+    {
+        PERIODIC = HIGH,
+        SPORADIC = NORMAL,
+        APERIODIC = LOW
     };
 
     // Policy events
     typedef int Event;
-    enum {
-        CREATE          = 1 << 0,
-        FINISH          = 1 << 1,
-        ENTER           = 1 << 2,
-        LEAVE           = 1 << 3,
-        JOB_RELEASE     = 1 << 4,
-        JOB_FINISH      = 1 << 5
+    enum
+    {
+        CREATE = 1 << 0,
+        FINISH = 1 << 1,
+        ENTER = 1 << 2,
+        LEAVE = 1 << 3,
+        JOB_RELEASE = 1 << 4,
+        JOB_FINISH = 1 << 5,
     };
 
     // Policy operations
     typedef int Operation;
-    enum {
-        COLLECT         = 1 << 16,
-        CHARGE          = 1 << 17,
-        AWARD           = 1 << 18,
-        UPDATE          = 1 << 19
+    enum
+    {
+        COLLECT = 1 << 16,
+        CHARGE = 1 << 17,
+        AWARD = 1 << 18,
+        UPDATE = 1 << 19
     };
 
     // Policy traits
@@ -77,40 +82,42 @@ public:
     static const unsigned int QUEUES = 1;
 
     // Runtime Statistics (for policies that don't use any; that's why its a union)
-    union Dummy_Statistics {  // for Traits<System>::monitored = false
+    union Dummy_Statistics
+    { // for Traits<System>::monitored = false
         // Thread related statistics
-        Tick thread_creation;                   // tick in which the thread was created
-        Tick thread_destruction;                // tick in which the thread was destroyed
-        Tick thread_execution_time;             // accumulated execution time (in ticks)
-        Tick thread_last_dispatch;              // tick in which the thread was last dispatched to the CPU
-        Tick thread_last_preemption;            // tick in which the thread left the CPU by the last time
+        Tick thread_creation;        // tick in which the thread was created
+        Tick thread_destruction;     // tick in which the thread was destroyed
+        Tick thread_execution_time;  // accumulated execution time (in ticks)
+        Tick thread_last_dispatch;   // tick in which the thread was last dispatched to the CPU
+        Tick thread_last_preemption; // tick in which the thread left the CPU by the last time
 
         // Job related statistics
         bool job_released;
-        Tick job_release;                       // tick in which the last job of a periodic thread was made ready for execution
-        Tick job_start;                         // tick in which the last job of a periodic thread started (different from "thread_last_dispatch" since jobs can be preempted)
-        Tick job_finish;                        // tick in which the last job of a periodic thread finished (i.e. called _alarm->p() at wait_netxt(); different from "thread_last_preemption" since jobs can be preempted)
-        Tick job_utilization;                   // accumulated execution time (in ticks)
-        unsigned int jobs_released;             // number of jobs of a thread that were released so far (i.e. the number of times _alarm->v() was called by the Alarm::handler())
-        unsigned int jobs_finished;             // number of jobs of a thread that finished execution so far (i.e. the number of times alarm->p() was called at wait_next())
+        Tick job_release;           // tick in which the last job of a periodic thread was made ready for execution
+        Tick job_start;             // tick in which the last job of a periodic thread started (different from "thread_last_dispatch" since jobs can be preempted)
+        Tick job_finish;            // tick in which the last job of a periodic thread finished (i.e. called _alarm->p() at wait_netxt(); different from "thread_last_preemption" since jobs can be preempted)
+        Tick job_utilization;       // accumulated execution time (in ticks)
+        unsigned int jobs_released; // number of jobs of a thread that were released so far (i.e. the number of times _alarm->v() was called by the Alarm::handler())
+        unsigned int jobs_finished; // number of jobs of a thread that finished execution so far (i.e. the number of times alarm->p() was called at wait_next())
     };
 
-    struct Real_Statistics {  // for Traits<System>::monitored = true
+    struct Real_Statistics
+    { // for Traits<System>::monitored = true
         // Thread related statistics
-        Tick thread_creation;                   // tick in which the thread was created
-        Tick thread_destruction;                // tick in which the thread was destroyed
-        Tick thread_execution_time;             // accumulated execution time (in ticks)
-        Tick thread_last_dispatch;              // tick in which the thread was last dispatched to the CPU
-        Tick thread_last_preemption;            // tick in which the thread left the CPU by the last time
+        Tick thread_creation;        // tick in which the thread was created
+        Tick thread_destruction;     // tick in which the thread was destroyed
+        Tick thread_execution_time;  // accumulated execution time (in ticks)
+        Tick thread_last_dispatch;   // tick in which the thread was last dispatched to the CPU
+        Tick thread_last_preemption; // tick in which the thread left the CPU by the last time
 
         // Job related statistics
         bool job_released;
-        Tick job_release;                       // tick in which the last job of a periodic thread was made ready for execution
-        Tick job_start;                         // tick in which the last job of a periodic thread started (different from "thread_last_dispatch" since jobs can be preempted)
-        Tick job_finish;                        // tick in which the last job of a periodic thread finished (i.e. called _alarm->p() at wait_netxt(); different from "thread_last_preemption" since jobs can be preempted)
-        Tick job_utilization;                   // accumulated execution time (in ticks)
-        unsigned int jobs_released;             // number of jobs of a thread that were released so far (i.e. the number of times _alarm->v() was called by the Alarm::handler())
-        unsigned int jobs_finished;             // number of jobs of a thread that finished execution so far (i.e. the number of times alarm->p() was called at wait_next())
+        Tick job_release;           // tick in which the last job of a periodic thread was made ready for execution
+        Tick job_start;             // tick in which the last job of a periodic thread started (different from "thread_last_dispatch" since jobs can be preempted)
+        Tick job_finish;            // tick in which the last job of a periodic thread finished (i.e. called _alarm->p() at wait_netxt(); different from "thread_last_preemption" since jobs can be preempted)
+        Tick job_utilization;       // accumulated execution time (in ticks)
+        unsigned int jobs_released; // number of jobs of a thread that were released so far (i.e. the number of times _alarm->v() was called by the Alarm::handler())
+        unsigned int jobs_finished; // number of jobs of a thread that finished execution so far (i.e. the number of times alarm->p() was called at wait_next())
     };
 
     typedef IF<Traits<System>::monitored, Real_Statistics, Dummy_Statistics>::Result Statistics;
@@ -119,13 +126,14 @@ protected:
     Scheduling_Criterion_Common() {}
 
 public:
-    Microsecond period() { return 0;}
+    Microsecond period() { return 0; }
     Microsecond deadline() { return 0; }
     Microsecond capacity() { return 0; }
 
     bool periodic() { return false; }
 
     volatile Statistics & statistics() { return _statistics; }
+    //P3 - Alteração
     unsigned int queue() const { return 0; }
 
 protected:
@@ -140,11 +148,11 @@ protected:
 };
 
 // Priority (static and dynamic)
-class Priority: public Scheduling_Criterion_Common
+class Priority : public Scheduling_Criterion_Common
 {
 public:
-    template <typename ... Tn>
-    Priority(int p = NORMAL, Tn & ... an): _priority(p) {}
+    template <typename... Tn>
+    Priority(int p = NORMAL, Tn &...an) : _priority(p) {}
 
     operator const volatile int() const volatile { return _priority; }
 
@@ -153,7 +161,7 @@ protected:
 };
 
 // Round-Robin
-class RR: public Priority
+class RR : public Priority
 {
 public:
     static const bool timed = true;
@@ -161,12 +169,12 @@ public:
     static const bool preemptive = true;
 
 public:
-    template <typename ... Tn>
-    RR(int p = NORMAL, Tn & ... an): Priority(p) {}
+    template <typename... Tn>
+    RR(int p = NORMAL, Tn &...an) : Priority(p) {}
 };
 
 // First-Come, First-Served (FIFO)
-class FCFS: public Priority
+class FCFS : public Priority
 {
 public:
     static const bool timed = false;
@@ -174,8 +182,8 @@ public:
     static const bool preemptive = false;
 
 public:
-    template <typename ... Tn>
-    FCFS(int p = NORMAL, Tn & ... an);
+    template <typename... Tn>
+    FCFS(int p = NORMAL, Tn &...an);
 };
 
 
@@ -248,20 +256,20 @@ public:
 };
 
 // Real-time Algorithms
-class RT_Common: public Priority
+class RT_Common : public Priority
 {
     friend class FCFS;
-    friend class Thread;                // for handle() and queue()
-    friend class Periodic_Thread;       // for handle() and queue()
-    friend class RT_Thread;             // for handle() and queue()
+    friend class Thread;          // for handle() and queue()
+    friend class Periodic_Thread; // for handle() and queue()
+    friend class RT_Thread;       // for handle() and queue()
 
 public:
     static const bool timed = true;
     static const bool preemptive = true;
 
 protected:
-    RT_Common(int i): Priority(i), _period(0), _deadline(0), _capacity(0) {} // aperiodic
-    RT_Common(int i, Microsecond p, Microsecond d, Microsecond c): Priority(i), _period(ticks(p)), _deadline(ticks(d ? d : p)), _capacity(ticks(c)) {}
+    RT_Common(int i) : Priority(i), _period(0), _deadline(0), _capacity(0) {} // aperiodic
+    RT_Common(int i, Microsecond p, Microsecond d, Microsecond c) : Priority(i), _period(ticks(p)), _deadline(ticks(d ? d : p)), _capacity(ticks(c)) {}
 
 public:
     Microsecond period() { return time(_period); }
@@ -270,7 +278,7 @@ public:
 
     bool periodic() { return (_priority >= PERIODIC) && (_priority <= SPORADIC); }
 
-    volatile Statistics & statistics() { return _statistics; }
+    volatile Statistics &statistics() { return _statistics; }
 
 protected:
     Tick ticks(Microsecond time);
@@ -288,7 +296,7 @@ protected:
 };
 
 // Rate Monotonic
-class RM:public RT_Common
+class RM : public RT_Common
 {
 public:
     static const bool dynamic = false;
@@ -299,7 +307,7 @@ public:
 };
 
 // Deadline Monotonic
-class DM: public RT_Common
+class DM : public RT_Common
 {
 public:
     static const bool dynamic = false;
@@ -310,7 +318,7 @@ public:
 };
 
 // Laxity Monotonic
-class LM: public RT_Common
+class LM : public RT_Common
 {
 public:
     static const bool dynamic = false;
@@ -321,7 +329,7 @@ public:
 };
 
 // Earliest Deadline First
-class EDF: public RT_Common
+class EDF : public RT_Common
 {
 public:
     static const bool dynamic = true;
@@ -333,9 +341,8 @@ public:
     void handle(Event event);
 };
 
-
 // Least Laxity First
-class LLF: public RT_Common
+class LLF : public RT_Common
 {
 public:
     static const bool dynamic = true;
@@ -347,10 +354,168 @@ public:
     void handle(Event event);
 };
 
+// Energy Aware Multi Queue
+class EAMQ : public RT_Common
+{
+
+public:
+    static const unsigned short QUEUES = 4;
+    static const unsigned int Q = Traits<Thread>::QUANTUM;
+    static const bool dynamic = true;
+
+public:
+    EAMQ(int p = APERIODIC);
+    EAMQ(Microsecond p, Microsecond d = SAME, Microsecond c = UNKNOWN);
+
+    enum
+    {
+        ASSURE_BEHIND = 1 << 6,
+        CHANGE_QUEUE = 1 << 7,
+        RESUME_THREAD = 1 << 8,
+        // LEAVING_QUEUE = 1 << 9   // Nao implementado ainda
+    };
+
+    struct Personal_Statistics
+    {
+        Microsecond remaining_deadline;         // deadline restante 
+        Microsecond remaining_et[QUEUES];       // tempo de execucao restante em cada frequencia (inicia como job_estimated_et)
+        Microsecond job_estimated_et[QUEUES];   // tempo de execução estimado em cada frequencia dada media
+        Microsecond average_et[QUEUES];         // tempo de execução média ponderada
+
+        Microsecond job_execution_time; // tempo de execução real acumulada da tarefa
+        Tick job_enter_tick;            // tempo de entrada do ultimo job
+    };
+
+    void handle(Event event);
+
+    Personal_Statistics personal_statistics() { return _personal_statistics; }
+
+    const bool is_recent_insertion() { return _is_recent_insertion; }
+    void is_recent_insertion(bool b) { _is_recent_insertion = b; }
+    const bool periodic() { return _periodic; }
+
+    int rank_eamq();
+    const volatile unsigned int &queue_eamq() const volatile { return _queue_eamq; } // returns the Thread's queue
+
+    static const volatile unsigned int &current_queue_eamq() { return _current_queue[CPU::id()]; } // current global queue
+    virtual void next_queue() { ++_current_queue[CPU::id()] %= QUEUES;}        // points to next global queue with threads
+
+protected:    
+    void set_queue(unsigned int q) { _queue_eamq = q; };
+
+    /* Em caso de 4 filas em relacao a frequencia maxima:
+     *   0 -> 100%
+     *   1 -> 87%
+     *   2 -> 75%
+     *   3 -> 62%
+     */
+    static Hertz frequency_within(unsigned int queue)
+    {
+        if (Traits<System>::RUN_TO_HALT) return CPU::max_clock(); 
+
+        Hertz f = CPU::max_clock() - (((CPU::max_clock() / 1000) * 125) * queue);
+        return f;
+    };
+
+    /* Procura pela melhor thread na subfila q (posicao a colocar), 
+     * onde o slack seja o menor possivel
+     */
+    Thread * search_t_fitted(unsigned int q);
+
+    /* Estima o tempo de espera (em numeros de quantums) que
+     * levaria ate o _current_queue chegar em q
+     */
+    int estimate_rp_waiting_time(unsigned int q);
+
+    static void initialize_current_queue() {
+        if (!initialized) {
+            for (volatile unsigned int &q : _current_queue) {
+                q = QUEUES - 1;
+            }
+            initialized = true;
+        }
+    }
+
+protected:
+    volatile unsigned int _queue_eamq;
+    bool _is_recent_insertion;
+    Personal_Statistics _personal_statistics;
+    Thread *_behind_of;
+    bool _periodic;
+    static bool initialized;
+
+    static volatile unsigned int _current_queue[Traits<Machine>::CPUS]; 
+};
+
+// P3TEST - Multicore Global Scheduling 
+class GEAMQ : public EAMQ
+{
+public:
+    static const unsigned HEADS = Traits<Machine>::CPUS;
+
+    // initialize_current_queue pois a main que é a primeira a rodar é aperiodica
+    GEAMQ(int p = APERIODIC): EAMQ(p) {initialize_current_queue();}
+    GEAMQ(const Microsecond p, const Microsecond d = SAME, const Microsecond c = UNKNOWN): EAMQ(p, d, c) {}
+    
+    using EAMQ::queue_eamq;
+    
+protected:
+    static volatile unsigned int _current_queue[HEADS];
+
+    static void initialize_current_queue() {
+        if (!initialized) {
+            for (volatile unsigned int &q : _current_queue) {
+                q = QUEUES - 1;
+            }
+            initialized = true;
+        }
+    }
+    static bool initialized;
+    
+
+public:
+    int rank_eamq();
+    void handle(Event event);
+
+    void next_queue() override { _current_queue[CPU::id()] = (_current_queue[CPU::id()] + 1) % QUEUES;}
+    
+    static const volatile unsigned int &current_queue() { return _current_queue[CPU::id()]; }
+    static unsigned int current_head() { return CPU::id(); }
+
+
+};
+
+class PEAMQ : public Variable_Queue_Scheduler, public EAMQ 
+{
+public: 
+    static const unsigned int QUEUES_CORES = Traits<Machine>::CPUS;
+
+    PEAMQ(int p = APERIODIC)
+    : Variable_Queue_Scheduler(((p == IDLE) || (p == MAIN)) ? CPU::id() : ++_next_queue %= CPU::cores()), EAMQ(p) {}
+    PEAMQ(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+    : Variable_Queue_Scheduler((cpu != ANY) ? cpu : evaluate()), EAMQ(p, d, c) {}
+
+    using Variable_Queue_Scheduler::queue;
+    static unsigned int current_queue() { return CPU::id(); }
+
+protected:
+    volatile unsigned int evaluate();
+
+};
+
 __END_SYS
 
 __BEGIN_UTIL
 
+template<typename T>
+class Scheduling_Queue<T, PEAMQ> : public Multilist_Scheduling_Multilist<T>{};
+
+// P3TEST - usando multihead multilist
+template <typename T>
+class Scheduling_Queue<T, GEAMQ> : public Multihead_Scheduling_Multilist<T>{};
+
+template <typename T>
+class Scheduling_Queue<T, EAMQ> : public Scheduling_Multilist_Single_Chosen<T>{};
 // Scheduling Queues
 template<typename T>
 class Scheduling_Queue<T, GRR>:
diff --git a/include/synchronizer.h b/include/synchronizer.h
index dc2bb2a..f450626 100644
--- a/include/synchronizer.h
+++ b/include/synchronizer.h
@@ -98,7 +98,9 @@ public:
     Semaphore_Handler(Semaphore * h) : _handler(h) {}
     ~Semaphore_Handler() {}
 
-    void operator()() { _handler->v(); }
+    void operator()() {
+        _handler->v(); 
+    }
 
 private:
     Semaphore * _handler;
diff --git a/include/system/traits.h b/include/system/traits.h
index 8e7d12c..4173d35 100644
--- a/include/system/traits.h
+++ b/include/system/traits.h
@@ -112,6 +112,10 @@ class DM;
 class LM;
 class EDF;
 class LLF;
+class EAMQ;
+class GEAMQ;
+class PEAMQ;
+class AAA;
 class GRR;
 class Fixed_CPU;
 class CPU_Affinity;
diff --git a/include/system/types.h b/include/system/types.h
index af8f717..3cc2edc 100644
--- a/include/system/types.h
+++ b/include/system/types.h
@@ -155,6 +155,8 @@ public:
     operator Time_Base() { return _time; }
     operator Time_Base() const { return _time; }
     operator Time_Base() volatile { return _time; }
+    Microsecond operator -=(const Microsecond& b) { return Microsecond(_time - Time_Base(b)); }
+    Microsecond operator +=(const Microsecond& b) { return Microsecond(_time + Time_Base(b)); }
 
 private:
     Time_Base _time;
diff --git a/include/utility/heap.h b/include/utility/heap.h
index fba63db..6323c64 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -10,7 +10,7 @@
 __BEGIN_UTIL
 
 // Heap
-class Heap: private Grouping_List<char>
+class Heap_Imp: private Grouping_List<char>
 {
 protected:
     static const bool typed = Traits<System>::multiheap;
@@ -20,11 +20,11 @@ public:
     using Grouping_List<char>::size;
     using Grouping_List<char>::grouped_size;
 
-    Heap() {
+    Heap_Imp() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
     }
 
-    Heap(void * addr, unsigned long bytes) {
+    Heap_Imp(void * addr, unsigned long bytes) {
         db<Init, Heaps>(TRC) << "Heap(addr=" << addr << ",bytes=" << bytes << ") => " << this << endl;
 
         free(addr, bytes);
@@ -76,11 +76,11 @@ public:
     static void typed_free(void * ptr) {
         long * addr = reinterpret_cast<long *>(ptr);
         unsigned long bytes = *--addr;
-        Heap * heap = reinterpret_cast<Heap *>(*--addr);
+        Heap_Imp * heap = reinterpret_cast<Heap_Imp *>(*--addr);
         heap->free(addr, bytes);
     }
 
-    static void untyped_free(Heap * heap, void * ptr) {
+    static void untyped_free(Heap_Imp * heap, void * ptr) {
         long * addr = reinterpret_cast<long *>(ptr);
         unsigned long bytes = *--addr;
         heap->free(addr, bytes);
@@ -150,7 +150,7 @@ private:
 };
 
 
-typedef Heap_Wrapper<Heap, Traits<System>::multicore> Application_Heap;
+typedef Heap_Wrapper<Heap_Imp, Traits<System>::multicore> Heap;
 
 __END_UTIL
 
diff --git a/include/utility/list.h b/include/utility/list.h
index 1a7107c..339e432 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -11,7 +11,7 @@ __BEGIN_UTIL
 class List_Element_Rank
 {
 public:
-    List_Element_Rank(int r = 0): _rank(r) {}
+    List_Element_Rank(int r = 0) : _rank(r) {}
 
     operator int() const { return _rank; }
 
@@ -19,14 +19,13 @@ protected:
     int _rank;
 };
 
-
 // List Elements
 namespace List_Elements
 {
     typedef List_Element_Rank Rank;
 
     // Vector Element
-    template<typename T>
+    template <typename T>
     class Pointer
     {
     public:
@@ -34,16 +33,16 @@ namespace List_Elements
         typedef Pointer Element;
 
     public:
-        Pointer(const T * o): _object(o) {}
+        Pointer(const T *o) : _object(o) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
     private:
-        const T * _object;
+        const T *_object;
     };
 
     // Hash Table Element
-    template<typename T, typename R = Rank>
+    template <typename T, typename R = Rank>
     class Ranked
     {
     public:
@@ -52,23 +51,31 @@ namespace List_Elements
         typedef Ranked Element;
 
     public:
-        Ranked(const T * o, const R & r = 0): _object(o), _rank(r) {}
+        Ranked(const T *o, const R &r = 0) : _object(o), _rank(r) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        const R & rank() const { return _rank; }
-        const R & key() const { return _rank; }
-        void rank(const R & r) { _rank = r; }
-        int promote(const R & n = 1) { _rank -= n; return _rank; }
-        int demote(const R & n = 1) { _rank += n; return _rank; }
+        const R &rank() const { return _rank; }
+        const R &key() const { return _rank; }
+        void rank(const R &r) { _rank = r; }
+        int promote(const R &n = 1)
+        {
+            _rank -= n;
+            return _rank;
+        }
+        int demote(const R &n = 1)
+        {
+            _rank += n;
+            return _rank;
+        }
 
     private:
-        const T * _object;
+        const T *_object;
         R _rank;
     };
 
     // Simple List Element
-    template<typename T>
+    template <typename T>
     class Singly_Linked
     {
     public:
@@ -76,21 +83,21 @@ namespace List_Elements
         typedef Singly_Linked Element;
 
     public:
-        Singly_Linked(const T * o): _object(o), _next(0) {}
+        Singly_Linked(const T *o) : _object(o), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * next() const { return _next; }
-        void next(Element * e) { _next = e; }
+        Element *next() const { return _next; }
+        void next(Element *e) { _next = e; }
 
     private:
-        const T * _object;
-        Element * _next;
+        const T *_object;
+        Element *_next;
     };
 
     // Simple Ordered List Element
     // Hash Table's Synonym List Element
-    template<typename T, typename R = Rank>
+    template <typename T, typename R = Rank>
     class Singly_Linked_Ordered
     {
     public:
@@ -99,27 +106,35 @@ namespace List_Elements
         typedef Singly_Linked_Ordered Element;
 
     public:
-        Singly_Linked_Ordered(const T * o, const R & r = 0): _object(o), _rank(r), _next(0) {}
+        Singly_Linked_Ordered(const T *o, const R &r = 0) : _object(o), _rank(r), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * next() const { return _next; }
-        void next(Element * e) { _next = e; }
+        Element *next() const { return _next; }
+        void next(Element *e) { _next = e; }
 
-        const R & rank() const { return _rank; }
-        const R & key() const { return _rank; }
-        void rank(const R & r) { _rank = r; }
-        int promote(const R & n = 1) { _rank -= n; return _rank; }
-        int demote(const R & n = 1) { _rank += n; return _rank; }
+        const R &rank() const { return _rank; }
+        const R &key() const { return _rank; }
+        void rank(const R &r) { _rank = r; }
+        int promote(const R &n = 1)
+        {
+            _rank -= n;
+            return _rank;
+        }
+        int demote(const R &n = 1)
+        {
+            _rank += n;
+            return _rank;
+        }
 
     private:
-        const T * _object;
+        const T *_object;
         R _rank;
-        Element * _next;
+        Element *_next;
     };
 
     // Simple Grouping List Element
-    template<typename T>
+    template <typename T>
     class Singly_Linked_Grouping
     {
     public:
@@ -127,12 +142,12 @@ namespace List_Elements
         typedef Singly_Linked_Grouping Element;
 
     public:
-        Singly_Linked_Grouping(const T * o, unsigned long s): _object(o), _size(s), _next(0) {}
+        Singly_Linked_Grouping(const T *o, unsigned long s) : _object(o), _size(s), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * next() const { return _next; }
-        void next(Element * e) { _next = e; }
+        Element *next() const { return _next; }
+        void next(Element *e) { _next = e; }
 
         unsigned long size() const { return _size; }
         void size(unsigned long l) { _size = l; }
@@ -140,13 +155,13 @@ namespace List_Elements
         void expand(unsigned long n) { _size += n; }
 
     private:
-        const T * _object;
+        const T *_object;
         unsigned long _size;
-        Element * _next;
+        Element *_next;
     };
 
     // List Element
-    template<typename T>
+    template <typename T>
     class Doubly_Linked
     {
     public:
@@ -154,23 +169,23 @@ namespace List_Elements
         typedef Doubly_Linked Element;
 
     public:
-        Doubly_Linked(const T * o): _object(o), _prev(0), _next(0) {}
+        Doubly_Linked(const T *o) : _object(o), _prev(0), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * prev() const { return _prev; }
-        Element * next() const { return _next; }
-        void prev(Element * e) { _prev = e; }
-        void next(Element * e) { _next = e; }
+        Element *prev() const { return _prev; }
+        Element *next() const { return _next; }
+        void prev(Element *e) { _prev = e; }
+        void next(Element *e) { _next = e; }
 
     private:
-        const T * _object;
-        Element * _prev;
-        Element * _next;
+        const T *_object;
+        Element *_prev;
+        Element *_next;
     };
 
     // Ordered List Element
-    template<typename T, typename R = Rank>
+    template <typename T, typename R = Rank>
     class Doubly_Linked_Ordered
     {
     public:
@@ -179,29 +194,37 @@ namespace List_Elements
         typedef Doubly_Linked_Ordered Element;
 
     public:
-        Doubly_Linked_Ordered(const T * o,  const R & r = 0): _object(o), _rank(r), _prev(0), _next(0) {}
+        Doubly_Linked_Ordered(const T *o, const R &r = 0) : _object(o), _rank(r), _prev(0), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * prev() const { return _prev; }
-        Element * next() const { return _next; }
-        void prev(Element * e) { _prev = e; }
-        void next(Element * e) { _next = e; }
+        Element *prev() const { return _prev; }
+        Element *next() const { return _next; }
+        void prev(Element *e) { _prev = e; }
+        void next(Element *e) { _next = e; }
 
-        const R & rank() const { return _rank; }
-        void rank(const R & r) { _rank = r; }
-        int promote(const R & n = 1) { _rank -= n; return _rank; }
-        int demote(const R & n = 1) { _rank += n; return _rank; }
+        const R &rank() const { return _rank; }
+        void rank(const R &r) { _rank = r; }
+        int promote(const R &n = 1)
+        {
+            _rank -= n;
+            return _rank;
+        }
+        int demote(const R &n = 1)
+        {
+            _rank += n;
+            return _rank;
+        }
 
     private:
-        const T * _object;
+        const T *_object;
         R _rank;
-        Element * _prev;
-        Element * _next;
+        Element *_prev;
+        Element *_next;
     };
 
     // Ordered List Element
-    template<typename T, typename R = Rank>
+    template <typename T, typename R = Rank>
     class Doubly_Linked_Typed
     {
     public:
@@ -210,27 +233,27 @@ namespace List_Elements
         typedef Doubly_Linked_Typed Element;
 
     public:
-        Doubly_Linked_Typed(const T * o,  const R & t = 0): _object(o), _type(t), _prev(0), _next(0) {}
+        Doubly_Linked_Typed(const T *o, const R &t = 0) : _object(o), _type(t), _prev(0), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * prev() const { return _prev; }
-        Element * next() const { return _next; }
-        void prev(Element * e) { _prev = e; }
-        void next(Element * e) { _next = e; }
+        Element *prev() const { return _prev; }
+        Element *next() const { return _next; }
+        void prev(Element *e) { _prev = e; }
+        void next(Element *e) { _next = e; }
 
-        const R & type() const { return _type; }
-        void rank(const R & t) { _type = t; }
+        const R &type() const { return _type; }
+        void rank(const R &t) { _type = t; }
 
     private:
-        const T * _object;
+        const T *_object;
         R _type;
-        Element * _prev;
-        Element * _next;
+        Element *_prev;
+        Element *_next;
     };
 
     // Scheduling List Element
-    template<typename T, typename R = Rank>
+    template <typename T, typename R = Rank>
     class Doubly_Linked_Scheduling
     {
     public:
@@ -239,30 +262,37 @@ namespace List_Elements
         typedef Doubly_Linked_Scheduling Element;
 
     public:
-        Doubly_Linked_Scheduling(const T * o,  const R & r = 0): _object(o), _rank(r), _prev(0), _next(0) {}
+        Doubly_Linked_Scheduling(const T *o, const R &r = 0) : _object(o), _rank(r), _prev(0), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * prev() const { return _prev; }
-        Element * next() const { return _next; }
-        void prev(Element * e) { _prev = e; }
-        void next(Element * e) { _next = e; }
+        Element *prev() const { return _prev; }
+        Element *next() const { return _next; }
+        void prev(Element *e) { _prev = e; }
+        void next(Element *e) { _next = e; }
 
-        const R & rank() const { return _rank; }
-        void rank(const R & r) { _rank = r; }
-        int promote(const R & n = 1) { _rank -= n; return _rank; }
-        int demote(const R & n = 1) { _rank += n; return _rank; }
+        const R &rank() const { return _rank; }
+        void rank(const R &r) { _rank = r; }
+        int promote(const R &n = 1)
+        {
+            _rank -= n;
+            return _rank;
+        }
+        int demote(const R &n = 1)
+        {
+            _rank += n;
+            return _rank;
+        }
 
     private:
-        const T * _object;
+        const T *_object;
         R _rank;
-        Element * _prev;
-        Element * _next;
+        Element *_prev;
+        Element *_next;
     };
 
-
     // Grouping List Element
-    template<typename T>
+    template <typename T>
     class Doubly_Linked_Grouping
     {
     public:
@@ -270,14 +300,14 @@ namespace List_Elements
         typedef Doubly_Linked_Grouping Element;
 
     public:
-        Doubly_Linked_Grouping(const T * o, unsigned long s): _object(o), _size(s), _prev(0), _next(0) {}
+        Doubly_Linked_Grouping(const T *o, unsigned long s) : _object(o), _size(s), _prev(0), _next(0) {}
 
-        T * object() const { return const_cast<T *>(_object); }
+        T *object() const { return const_cast<T *>(_object); }
 
-        Element * prev() const { return _prev; }
-        Element * next() const { return _next; }
-        void prev(Element * e) { _prev = e; }
-        void next(Element * e) { _next = e; }
+        Element *prev() const { return _prev; }
+        Element *next() const { return _next; }
+        void prev(Element *e) { _prev = e; }
+        void next(Element *e) { _next = e; }
 
         unsigned long size() const { return _size; }
         void size(unsigned long l) { _size = l; }
@@ -285,19 +315,18 @@ namespace List_Elements
         void expand(unsigned long n) { _size += n; }
 
     private:
-        const T * _object;
+        const T *_object;
         unsigned long _size;
-        Element * _prev;
-        Element * _next;
+        Element *_prev;
+        Element *_next;
     };
 };
 
-
 // List Iterators
 namespace List_Iterators
 {
     // Forward Iterator (for singly linked lists)
-    template<typename El>
+    template <typename El>
     class Forward
     {
     private:
@@ -307,26 +336,35 @@ namespace List_Iterators
         typedef El Element;
 
     public:
-        Forward(): _current(0) {}
-        Forward(Element * e): _current(e) {}
+        Forward() : _current(0) {}
+        Forward(Element *e) : _current(e) {}
 
         operator Element *() const { return _current; }
 
-        Element & operator*() const { return *_current; }
-        Element * operator->() const { return _current; }
+        Element &operator*() const { return *_current; }
+        Element *operator->() const { return _current; }
 
-        Iterator & operator++() { _current = _current->next(); return *this; }
-        Iterator operator++(int) { Iterator tmp = *this; ++*this; return tmp; }
+        Iterator &operator++()
+        {
+            _current = _current->next();
+            return *this;
+        }
+        Iterator operator++(int)
+        {
+            Iterator tmp = *this;
+            ++*this;
+            return tmp;
+        }
 
-        bool operator==(const Iterator & i) const { return _current == i._current; }
-        bool operator!=(const Iterator & i) const { return _current != i._current; }
+        bool operator==(const Iterator &i) const { return _current == i._current; }
+        bool operator!=(const Iterator &i) const { return _current != i._current; }
 
     protected:
-        Element * _current;
+        Element *_current;
     };
 
     // Bidirectional Iterator (for doubly linked lists)
-    template<typename El>
+    template <typename El>
     class Bidirecional
     {
     private:
@@ -336,30 +374,48 @@ namespace List_Iterators
         typedef El Element;
 
     public:
-        Bidirecional(): _current(0) {}
-        Bidirecional(Element * e): _current(e) {}
+        Bidirecional() : _current(0) {}
+        Bidirecional(Element *e) : _current(e) {}
 
         operator Element *() const { return _current; }
 
-        Element & operator*() const { return *_current; }
-        Element * operator->() const { return _current; }
+        Element &operator*() const { return *_current; }
+        Element *operator->() const { return _current; }
 
-        Iterator & operator++() { _current = _current->next(); return *this; }
-        Iterator operator++(int) { Iterator tmp = *this; ++*this; return tmp; }
+        Iterator &operator++()
+        {
+            _current = _current->next();
+            return *this;
+        }
+        Iterator operator++(int)
+        {
+            Iterator tmp = *this;
+            ++*this;
+            return tmp;
+        }
 
-        Iterator & operator--() { _current = _current->prev(); return *this; }
-        Iterator operator--(int) { Iterator tmp = *this; --*this; return tmp; }
+        Iterator &operator--()
+        {
+            _current = _current->prev();
+            return *this;
+        }
+        Iterator operator--(int)
+        {
+            Iterator tmp = *this;
+            --*this;
+            return tmp;
+        }
 
-        bool operator==(const Iterator & i) const { return _current == i._current; }
-        bool operator!=(const Iterator & i) const { return _current != i._current; }
+        bool operator==(const Iterator &i) const { return _current == i._current; }
+        bool operator!=(const Iterator &i) const { return _current != i._current; }
 
     private:
-        Element * _current;
+        Element *_current;
     };
 }
 
 // Singly-Linked List
-template<typename T, typename El = List_Elements::Singly_Linked<T> >
+template <typename T, typename El = List_Elements::Singly_Linked<T>>
 class Simple_List
 {
 public:
@@ -368,33 +424,37 @@ public:
     typedef List_Iterators::Forward<El> Iterator;
 
 public:
-    Simple_List(): _size(0), _head(0), _tail(0) {}
+    Simple_List() : _size(0), _head(0), _tail(0) {}
 
     bool empty() const { return (_size == 0); }
     unsigned long size() const { return _size; }
 
-    Element * head() { return _head; }
-    Element * tail() { return _tail; }
+    Element *head() { return _head; }
+    Element *tail() { return _tail; }
 
     Iterator begin() { return Iterator(_head); }
     Iterator end() { return Iterator(0); }
 
-    void insert(Element * e) { insert_tail(e); }
+    void insert(Element *e) { insert_tail(e); }
 
-    void insert_head(Element * e) {
-        if(empty())
+    void insert_head(Element *e)
+    {
+        if (empty())
             insert_first(e);
-        else {
+        else
+        {
             e->next(_head);
             _head = e;
             _size++;
         }
     }
 
-    void insert_tail(Element * e) {
-        if(empty())
+    void insert_tail(Element *e)
+    {
+        if (empty())
             insert_first(e);
-        else {
+        else
+        {
             _tail->next(e);
             e->next(0);
             _tail = e;
@@ -402,74 +462,85 @@ public:
         }
     }
 
-    Element * remove() { return remove_head(); }
+    Element *remove() { return remove_head(); }
 
-    Element * remove(Element * e) {
-        if(last())
+    Element *remove(Element *e)
+    {
+        if (last())
             remove_last();
-        else if(e == _head)
+        else if (e == _head)
             remove_head();
-        else {
-            Element * p = _head;
-            for(; p && p->next() && (p->next() != e); p = p->next());
-            if(p)
+        else
+        {
+            Element *p = _head;
+            for (; p && p->next() && (p->next() != e); p = p->next())
+                ;
+            if (p)
                 p->next(e->next());
-            if(e == _tail)
+            if (e == _tail)
                 _tail = p;
             _size--;
         }
         return e;
     }
 
-    Element * remove_head() {
-        if(empty())
+    Element *remove_head()
+    {
+        if (empty())
             return 0;
-        if(last())
+        if (last())
             return remove_last();
-        Element * e = _head;
+        Element *e = _head;
         _head = _head->next();
         _size--;
         return e;
     }
 
-    Element * remove_tail() {
-        if(_tail)
+    Element *remove_tail()
+    {
+        if (_tail)
             return remove(_tail);
         else
             return 0;
     }
 
-    Element * remove(const Object_Type * obj) {
-        Element * e = search(obj);
-        if(e)
+    Element *remove(const Object_Type *obj)
+    {
+        Element *e = search(obj);
+        if (e)
             return remove(e);
         return 0;
     }
 
-    Element * search(const Object_Type * obj) {
-        Element * e = _head;
-        for(; e && (e->object() != obj); e = e->next());
+    Element *search(const Object_Type *obj)
+    {
+        Element *e = _head;
+        for (; e && (e->object() != obj); e = e->next())
+            ;
         return e;
     }
 
 protected:
     bool last() const { return (_size == 1); }
 
-    void insert(Element * e, Element * p,  Element * n) {
+    void insert(Element *e, Element *p, Element *n)
+    {
         p->next(e);
         e->next(n);
         _size++;
     }
 
-    void insert_first(Element * e) {
+    void insert_first(Element *e)
+    {
         e->next(0);
         _head = e;
         _tail = e;
         _size++;
     }
 
-    Element * remove_last() {
-        Element * e = _head;
+    Element *remove_last()
+    {
+        Element *e = _head;
         _head = 0;
         _tail = 0;
         _size--;
@@ -478,17 +549,16 @@ protected:
 
 private:
     unsigned long _size;
-    Element * _head;
-    Element * _tail;
+    Element *_head;
+    Element *_tail;
 };
 
-
 // Singly-Linked, Ordered List
-template<typename T,
+template <typename T,
           typename R = List_Element_Rank,
           typename El = List_Elements::Singly_Linked_Ordered<T, R>,
           bool relative = false>
-class Simple_Ordered_List: public Simple_List<T, El>
+class Simple_Ordered_List : public Simple_List<T, El>
 {
 private:
     typedef Simple_List<T, El> Base;
@@ -504,89 +574,102 @@ public:
     typedef List_Iterators::Forward<El> Iterator;
 
 public:
-    using Base::empty;
-    using Base::size;
-    using Base::head;
-    using Base::tail;
     using Base::begin;
+    using Base::empty;
     using Base::end;
+    using Base::head;
     using Base::remove_head;
     using Base::remove_tail;
     using Base::search;
+    using Base::size;
+    using Base::tail;
 
-    void insert(Element * e) {
-        if(empty())
+    void insert(Element *e)
+    {
+        if (empty())
             insert_first(e);
-        else {
-            Element * next, * prev;
-            for(next = head(), prev = 0;
-                (next->rank() <= e->rank()) && next->next();
-                prev = next, next = next->next())
-                if(relative)
+        else
+        {
+            Element *next, *prev;
+            for (next = head(), prev = 0;
+                 (next->rank() <= e->rank()) && next->next();
+                 prev = next, next = next->next())
+                if (relative)
                     e->rank(e->rank() - next->rank());
-            if(next->rank() <= e->rank()) {
-                if(relative)
+            if (next->rank() <= e->rank())
+            {
+                if (relative)
                     e->rank(e->rank() - next->rank());
                 insert_tail(e);
-            } else if(!prev) {
-                if(relative)
+            }
+            else if (!prev)
+            {
+                if (relative)
                     next->rank(next->rank() - e->rank());
                 insert_head(e);
-            } else {
-                if(relative)
+            }
+            else
+            {
+                if (relative)
                     next->rank(next->rank() - e->rank());
                 Base::insert(e, prev, next);
             }
         }
     }
 
-    Element * remove() {
-        Element * e = remove_head();
-        if(e && relative && e->next())
+    Element *remove()
+    {
+        Element *e = remove_head();
+        if (e && relative && e->next())
             e->next()->rank(e->next()->rank() + e->rank());
         return e;
     }
 
-    Element * remove(Element * e) {
+    Element *remove(Element *e)
+    {
         Base::remove(e);
-        if(relative && e->next())
+        if (relative && e->next())
             e->next()->rank(e->next()->rank() + e->rank());
         return e;
     }
 
-    Element * remove(const Object_Type * obj) {
-        Element * e = search(obj);
-        if(e)
+    Element *remove(const Object_Type *obj)
+    {
+        Element *e = search(obj);
+        if (e)
             return remove(e);
         return 0;
     }
 
-    Element * search_rank(const Rank_Type & rank) {
-        Element * e = head();
-        for(; e && (e->rank() != rank); e = e->next());
+    Element *search_rank(const Rank_Type &rank)
+    {
+        Element *e = head();
+        for (; e && (e->rank() != rank); e = e->next())
+            ;
         return e;
     }
 
-    Element * remove_rank(const Rank_Type & rank) {
-        Element * e = search_rank(rank);
-        if(e)
+    Element *remove_rank(const Rank_Type &rank)
+    {
+        Element *e = search_rank(rank);
+        if (e)
             return remove(e);
         return 0;
     }
 };
 
-
 // Singly-Linked, Relative Ordered List
-template<typename T,
+template <typename T,
           typename R = List_Element_Rank,
-          typename El = List_Elements::Singly_Linked_Ordered<T, R> >
-class Simple_Relative_List: public Simple_Ordered_List<T, R, El, true> {};
-
+          typename El = List_Elements::Singly_Linked_Ordered<T, R>>
+class Simple_Relative_List : public Simple_Ordered_List<T, R, El, true>
+{
+};
 
 // Singly-Linked, Grouping List
-template<typename T,
-          typename El = List_Elements::Singly_Linked_Grouping<T> >
-class Simple_Grouping_List: public Simple_List<T, El>
+template <typename T,
+          typename El = List_Elements::Singly_Linked_Grouping<T>>
+class Simple_Grouping_List : public Simple_List<T, El>
 {
 private:
     typedef Simple_List<T, El> Base;
@@ -597,63 +680,74 @@ public:
     typedef List_Iterators::Forward<El> Iterator;
 
 public:
-    Simple_Grouping_List(): _grouped_size(0) {}
+    Simple_Grouping_List() : _grouped_size(0) {}
 
-    using Base::empty;
-    using Base::size;
-    using Base::head;
-    using Base::tail;
     using Base::begin;
+    using Base::empty;
     using Base::end;
+    using Base::head;
     using Base::insert_first;
     using Base::insert_head;
     using Base::insert_tail;
-    using Base::search;
     using Base::remove;
+    using Base::search;
+    using Base::size;
+    using Base::tail;
 
     unsigned long grouped_size() const { return _grouped_size; }
 
-    Element * search_size(unsigned long s) {
-        Element * e = head();
-        if(sizeof(Object_Type) < sizeof(Element))
-            for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
+    Element *search_size(unsigned long s)
+    {
+        Element *e = head();
+        if (sizeof(Object_Type) < sizeof(Element))
+            for (; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next())
+                ;
         else
-            for(; e && (e->size() < s); e = e->next());
+            for (; e && (e->size() < s); e = e->next())
+                ;
         return e;
     }
 
-    void insert_merging(Element * e, Element ** m1, Element ** m2) {
+    void insert_merging(Element *e, Element **m1, Element **m2)
+    {
         _grouped_size += e->size();
         *m1 = *m2 = 0;
-        Element * r = search(e->object() + e->size());
-        Element * l = search_left(e->object());
-        if(r) {
+        Element *r = search(e->object() + e->size());
+        Element *l = search_left(e->object());
+        if (r)
+        {
             e->size(e->size() + r->size());
             remove(r);
             *m1 = r;
         }
-        if(l) {
+        if (l)
+        {
             l->size(l->size() + e->size());
             *m2 = e;
-        } else
+        }
+        else
             insert_tail(e);
     }
 
-    Element * search_decrementing(unsigned long s) {
-        Element * e = search_size(s);
-        if(e) {
+    Element *search_decrementing(unsigned long s)
+    {
+        Element *e = search_size(s);
+        if (e)
+        {
             e->shrink(s);
             _grouped_size -= s;
-            if(!e->size())
+            if (!e->size())
                 remove(e);
         }
         return e;
     }
 
 private:
-    Element * search_left(const Object_Type * obj) {
-        Element * e = head();
-        for(; e && (e->object() + e->size() != obj); e = e->next());
+    Element *search_left(const Object_Type *obj)
+    {
+        Element *e = head();
+        for (; e && (e->object() + e->size() != obj); e = e->next())
+            ;
         return e;
     }
 
@@ -661,10 +755,9 @@ private:
     unsigned long _grouped_size;
 };
 
-
 // Doubly-Linked List
-template<typename T,
-          typename El = List_Elements::Doubly_Linked<T> >
+template <typename T,
+          typename El = List_Elements::Doubly_Linked<T>>
 class List
 {
 public:
@@ -673,32 +766,34 @@ public:
     typedef List_Iterators::Bidirecional<El> Iterator;
 
 public:
-    List(): _size(0), _head(0), _tail(0) {}
+    List() : _size(0), _head(0), _tail(0) {}
 
     bool empty() const { return (_size == 0); }
     unsigned long size() const { return _size; }
 
-    Element * head() { return _head; }
-    Element * tail() { return _tail; }
+    Element *head() { return _head; }
+    Element *tail() { return _tail; }
 
     Iterator begin() { return Iterator(_head); }
     Iterator end() { return Iterator(0); }
 
-    void insert(Element * e) { insert_tail(e); }
+    void insert(Element *e) { insert_tail(e); }
 
-    void insert_head(Element * e) {
+    void insert_head(Element *e)
+    {
         db<Lists>(TRC) << "List::insert_head(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
         print_head();
         print_tail();
 
-        if(empty())
+        if (empty())
             insert_first(e);
-        else {
+        else
+        {
             e->prev(0);
             e->next(_head);
             _head->prev(e);
@@ -710,19 +805,21 @@ public:
         print_tail();
     }
 
-    void insert_tail(Element * e) {
+    void insert_tail(Element *e)
+    {
         db<Lists>(TRC) << "List::insert_tail(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
         print_head();
         print_tail();
 
-        if(empty())
+        if (empty())
             insert_first(e);
-        else {
+        else
+        {
             _tail->next(e);
             e->prev(_tail);
             e->next(0);
@@ -734,25 +831,27 @@ public:
         print_tail();
     }
 
-    Element * remove() { return remove_head(); }
+    Element *remove() { return remove_head(); }
 
-    Element * remove(Element * e) {
+    Element *remove(Element *e)
+    {
         db<Lists>(TRC) << "List::remove(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
         print_head();
         print_tail();
 
-        if(last())
+        if (last())
             remove_last();
-        else if(!e->prev())
+        else if (!e->prev())
             remove_head();
-        else if(!e->next())
+        else if (!e->next())
             remove_tail();
-        else {
+        else
+        {
             e->prev()->next(e->next());
             e->next()->prev(e->prev());
             _size--;
@@ -764,17 +863,18 @@ public:
         return e;
     }
 
-    Element * remove_head() {
+    Element *remove_head()
+    {
         db<Lists>(TRC) << "List::remove_head()" << endl;
 
         print_head();
         print_tail();
 
-        if(empty())
+        if (empty())
             return 0;
-        if(last())
+        if (last())
             return remove_last();
-        Element * e = _head;
+        Element *e = _head;
         _head = _head->next();
         _head->prev(0);
         _size--;
@@ -785,17 +885,18 @@ public:
         return e;
     }
 
-    Element * remove_tail() {
+    Element *remove_tail()
+    {
         db<Lists>(TRC) << "List::remove_tail()" << endl;
 
         print_head();
         print_tail();
 
-        if(empty())
+        if (empty())
             return 0;
-        if(last())
+        if (last())
             return remove_last();
-        Element * e = _tail;
+        Element *e = _tail;
         _tail = _tail->prev();
         _tail->next(0);
         _size--;
@@ -806,33 +907,37 @@ public:
         return e;
     }
 
-    Element * remove(const Object_Type * obj) {
-        Element * e = search(obj);
-        if(e)
+    Element *remove(const Object_Type *obj)
+    {
+        Element *e = search(obj);
+        if (e)
             return remove(e);
         return 0;
     }
 
-    Element * search(const Object_Type * obj) {
-        Element * e = _head;
-        for(; e && (e->object() != obj); e = e->next());
+    Element *search(const Object_Type *obj)
+    {
+        Element *e = _head;
+        for (; e && (e->object() != obj); e = e->next())
+            ;
         return e;
     }
 
 protected:
     bool last() const { return (_size == 1); }
 
-    void insert(Element * e, Element * p,  Element * n) {
+    void insert(Element *e, Element *p, Element *n)
+    {
         db<Lists>(TRC) << "List::insert(e=" << e << ",p=" << p << ",n=" << n
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
-                       << "},{p=" << (p ? p->prev() : (void *) -1)
-                       << ",o=" << (p ? p->object() : (void *) -1)
-                       << ",n=" << (p ? p->next() : (void *) -1)
-                       << "},{p=" << (n ? n->prev() : (void *) -1)
-                       << ",o=" << (n ? n->object() : (void *) -1)
-                       << ",n=" << (n ? n->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
+                       << "},{p=" << (p ? p->prev() : (void *)-1)
+                       << ",o=" << (p ? p->object() : (void *)-1)
+                       << ",n=" << (p ? p->next() : (void *)-1)
+                       << "},{p=" << (n ? n->prev() : (void *)-1)
+                       << ",o=" << (n ? n->object() : (void *)-1)
+                       << ",n=" << (n ? n->next() : (void *)-1)
                        << "}" << endl;
 
         print_head();
@@ -848,11 +953,12 @@ protected:
         print_tail();
     }
 
-    void insert_first(Element * e) {
+    void insert_first(Element *e)
+    {
         db<Lists>(TRC) << "List::insert_first(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
         print_head();
@@ -868,13 +974,14 @@ protected:
         print_tail();
     }
 
-    Element * remove_last() {
+    Element *remove_last()
+    {
         db<Lists>(TRC) << "List::remove_last()" << endl;
 
         print_head();
         print_tail();
 
-        Element * e = _head;
+        Element *e = _head;
         _head = 0;
         _tail = 0;
         _size--;
@@ -885,35 +992,36 @@ protected:
         return e;
     }
 
-    void print_head() {
+    void print_head()
+    {
         db<Lists>(INF) << "List[" << this << "]::head=" << head()
-                       << " => {p=" << (head() ? head()->prev() : (void *) -1)
-                       << ",o=" << (head() ? head()->object() : (void *) -1)
-                       << ",n=" << (head() ? head()->next() : (void *) -1)
+                       << " => {p=" << (head() ? head()->prev() : (void *)-1)
+                       << ",o=" << (head() ? head()->object() : (void *)-1)
+                       << ",n=" << (head() ? head()->next() : (void *)-1)
                        << "}" << endl;
     }
 
-    void print_tail() {
+    void print_tail()
+    {
         db<Lists>(INF) << "List[" << this << "]::tail=" << tail()
-                       << " => {p=" << (tail() ? tail()->prev() : (void *) -1)
-                       << ",o=" << (tail() ? tail()->object() : (void *) -1)
-                       << ",n=" << (tail() ? tail()->next() : (void *) -1)
+                       << " => {p=" << (tail() ? tail()->prev() : (void *)-1)
+                       << ",o=" << (tail() ? tail()->object() : (void *)-1)
+                       << ",n=" << (tail() ? tail()->next() : (void *)-1)
                        << "}" << endl;
     }
 
 private:
     unsigned long _size;
-    Element * _head;
-    Element * _tail;
+    Element *_head;
+    Element *_tail;
 };
 
-
 // Doubly-Linked, Ordered List
-template<typename T,
+template <typename T,
           typename R = List_Element_Rank,
           typename El = List_Elements::Doubly_Linked_Ordered<T, R>,
           bool relative = false>
-class Ordered_List: public List<T, El>
+class Ordered_List : public List<T, El>
 {
 private:
     typedef List<T, El> Base;
@@ -925,127 +1033,141 @@ public:
     typedef List_Iterators::Bidirecional<El> Iterator;
 
 public:
-    using Base::empty;
-    using Base::size;
-    using Base::head;
-    using Base::tail;
     using Base::begin;
+    using Base::empty;
     using Base::end;
+    using Base::head;
     using Base::insert_first;
     using Base::insert_head;
     using Base::insert_tail;
     using Base::search;
+    using Base::size;
+    using Base::tail;
 
-    void insert(Element * e) {
+    void insert(Element *e)
+    {
         db<Lists>(TRC) << "Ordered_List::insert(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
-        if(empty())
+        if (empty())
             insert_first(e);
-        else {
-            Element * next;
-            for(next = head();
-                (next->rank() <= e->rank()) && next->next();
-                next = next->next())
-                if(relative)
+        else
+        {
+            Element *next;
+            for (next = head();
+                 (next->rank() <= e->rank()) && next->next();
+                 next = next->next())
+                if (relative)
                     e->rank(e->rank() - next->rank());
-            if(next->rank() <= e->rank()) {
-                if(relative)
+            if (next->rank() <= e->rank())
+            {
+                if (relative)
                     e->rank(e->rank() - next->rank());
                 insert_tail(e);
-            } else if(!next->prev()) {
-                if(relative)
+            }
+            else if (!next->prev())
+            {
+                if (relative)
                     next->rank(next->rank() - e->rank());
                 insert_head(e);
-            } else {
-                if(relative)
+            }
+            else
+            {
+                if (relative)
                     next->rank(next->rank() - e->rank());
                 Base::insert(e, next->prev(), next);
             }
         }
     }
 
-    Element * remove() {
+    Element *remove()
+    {
         db<Lists>(TRC) << "Ordered_List::remove()" << endl;
-        Element * e = Base::remove_head();
-        if(e && relative && e->next())
+        Element *e = Base::remove_head();
+        if (e && relative && e->next())
             e->next()->rank(e->next()->rank() + e->rank());
         return e;
     }
 
-    Element * remove(Element * e) {
+    Element *remove(Element *e)
+    {
         db<Lists>(TRC) << "Ordered_List::remove(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
         Base::remove(e);
-        if(relative && e->next())
+        if (relative && e->next())
             e->next()->rank(e->next()->rank() + e->rank());
 
         return e;
     }
 
-    Element * remove(const Object_Type * obj) {
+    Element *remove(const Object_Type *obj)
+    {
         db<Lists>(TRC) << "Ordered_List::remove(o=" << obj << ")" << endl;
 
-        Element * e = search(obj);
-        if(e)
+        Element *e = search(obj);
+        if (e)
             return remove(e);
         else
             return 0;
     }
 
-    Element * search_rank(const Rank_Type & rank) {
-        Element * e = head();
-        for(; e && (e->rank() != rank); e = e->next());
+    Element *search_rank(const Rank_Type &rank)
+    {
+        Element *e = head();
+        for (; e && (e->rank() != rank); e = e->next())
+            ;
         return e;
     }
 
-    Element * remove_rank(const Rank_Type & rank) {
+    Element *remove_rank(const Rank_Type &rank)
+    {
         db<Lists>(TRC) << "Ordered_List::remove_rank(r=" << rank << ")" << endl;
 
-        Element * e = search_rank(rank);
-        if(e)
+        Element *e = search_rank(rank);
+        if (e)
             return remove(e);
         return 0;
     }
 };
 
-
 // Doubly-Linked, Relative Ordered List
-template<typename T,
+template <typename T,
           typename R = List_Element_Rank,
-          typename El = List_Elements::Doubly_Linked_Ordered<T, R> >
-class Relative_List: public Ordered_List<T, R, El, true> {};
-
+          typename El = List_Elements::Doubly_Linked_Ordered<T, R>>
+class Relative_List : public Ordered_List<T, R, El, true>
+{
+};
 
 // Doubly-Linked, Typed List
-template<typename T = void,
+template <typename T = void,
           typename R = List_Element_Rank,
           typename El = List_Elements::Doubly_Linked_Typed<T, R>,
           bool relative = false>
-class Typed_List: public List<T, El> {};
-
+class Typed_List : public List<T, El>
+{
+};
 
 // Doubly-Linked, Scheduling List
 // Objects subject to scheduling must export a type "Criterion" compatible
 // with those available at scheduler.h .
 // In this implementation, the chosen element is kept outside the list
 // referenced by the _chosen attribute.
-template<typename T,
+template <typename T,
           typename R = typename T::Criterion,
-          typename El = List_Elements::Doubly_Linked_Scheduling<T, R> >
-class Scheduling_List: private Ordered_List<T, R, El>
+          typename El = List_Elements::Doubly_Linked_Scheduling<T, R>>
+class Scheduling_List : private Ordered_List<T, R, El>
 {
-    template<typename FT, typename FR, typename FEl, unsigned int FH>
-    friend class Multihead_Scheduling_List;     // for chosen() and remove()
-    template<typename FT, typename FR, typename FEl, typename FL, unsigned int FQ>
-    friend class Scheduling_Multilist;          // for chosen() and remove()
+    template <typename FT, typename FR, typename FEl, unsigned int FH>
+    friend class Multihead_Scheduling_List; // for chosen() and remove()
+    template <typename FT, typename FR, typename FEl, typename FL, unsigned int FQ>
+    friend class Scheduling_Multilist; // for chosen() and remove()
 
 private:
     typedef Ordered_List<T, R, El> Base;
@@ -1057,38 +1179,40 @@ public:
     typedef typename Base::Iterator Iterator;
 
 public:
-    Scheduling_List(): _chosen(0) {}
+    Scheduling_List() : _chosen(0) {}
 
+    using Base::begin;
     using Base::empty;
-    using Base::size;
+    using Base::end;
     using Base::head;
+    using Base::size;
     using Base::tail;
-    using Base::begin;
-    using Base::end;
 
-    Element * volatile & chosen() { return _chosen; }
+    Element *volatile &chosen() { return _chosen; }
 
-    void insert(Element * e) {
+    void insert(Element *e)
+    {
         db<Lists>(TRC) << "Scheduling_List::insert(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
-        if(_chosen)
+        if (_chosen)
             Base::insert(e);
         else
             _chosen = e;
     }
 
-    Element * remove(Element * e) {
+    Element *remove(Element *e)
+    {
         db<Lists>(TRC) << "Scheduling_List::remove(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
-        if(e == _chosen)
+        if (e == _chosen)
             _chosen = Base::remove_head();
         else
             e = Base::remove(e);
@@ -1096,10 +1220,12 @@ public:
         return e;
     }
 
-    Element * choose() {
+    Element *choose()
+    {
         db<Lists>(TRC) << "Scheduling_List::choose()" << endl;
 
-        if(!empty()) {
+        if (!empty())
+        {
             Base::insert(_chosen);
             _chosen = Base::remove_head();
         }
@@ -1107,11 +1233,13 @@ public:
         return _chosen;
     }
 
-    Element * choose_another() {
+    Element *choose_another()
+    {
         db<Lists>(TRC) << "Scheduling_List::choose_another()" << endl;
 
-        if(!empty() && head()->rank() != R::IDLE) {
-            Element * tmp = _chosen;
+        if (!empty() && head()->rank() != R::IDLE)
+        {
+            Element *tmp = _chosen;
             _chosen = Base::remove_head();
             Base::insert(tmp);
         }
@@ -1119,14 +1247,16 @@ public:
         return _chosen;
     }
 
-    Element * choose(Element * e) {
+    Element *choose(Element *e)
+    {
         db<Lists>(TRC) << "Scheduling_List::choose(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
-        if(e != _chosen) {
+        if (e != _chosen)
+        {
             Base::insert(_chosen);
             _chosen = Base::remove(e);
         }
@@ -1136,26 +1266,259 @@ public:
 
 private:
     using Base::remove;
-    void chosen(Element * e) { _chosen = e; }
+    void chosen(Element *e) { _chosen = e; }
 
 private:
-    Element * volatile _chosen;
+    Element *volatile _chosen;
 };
 
+// Estrutura de lista similar a Multilist, com único chosen
+// Adaptando para nosso algoritmo
+template <typename T,
+          typename R = typename T::Criterion,
+          typename El = List_Elements::Doubly_Linked_Scheduling<T, R>,
+          typename L = Ordered_List<T, R, El>,
+          unsigned int Q = R::QUEUES>
+class Scheduling_Multilist_Single_Chosen : private Ordered_List<T, R, El>
+{
+private:
+    typedef Ordered_List<T, R, El> Base;
+public:
+    typedef T Object_Type;
+    typedef R Rank_Type;
+    typedef El Element;
+    typedef typename L::Iterator Iterator;
+
+
+public:
+    Scheduling_Multilist_Single_Chosen() { _total_size = 0; }
+
+    using Base::begin;
+    using Base::empty;
+    using Base::end;
+    using Base::head;
+    using Base::size;
+    using Base::tail;
+
+    bool empty() const { return _list[R::current_queue_eamq()].empty(); }
+    bool empty(unsigned int queue) { return _list[queue].empty(); }
+
+    unsigned long size() const { return _list[R::current_queue_eamq()].size(); }
+    unsigned long size(unsigned int queue) const { return _list[queue].size(); }
+
+    unsigned long total_size() const { return _total_size; }
+
+    Element *head() { return _list[R::current_queue_eamq()].head(); }
+    Element *head(unsigned int i) { return _list[i].head(); }
+    Element *tail() { return _list[R::current_queue_eamq()].tail(); }
+    Element *tail(unsigned int i) { return _list[i].tail(); }
+
+    Iterator begin() { return Iterator(_list[R::current_queue_eamq()].head()); }
+    Iterator begin(unsigned int queue) { return Iterator(_list[queue].head()); }
+    Iterator end() { return Iterator(0); }
+    Iterator end(unsigned int queue) { return Iterator(_list[queue].tail()); }
+
+    // Quantidade de filas ocupadas em determinado momento
+    const int occupied_queues() { return _occupied_queues; }
+
+    // Se não tem _chosen -> escolhe chosen
+    Element *volatile &chosen() {
+        if (!_chosen) {
+            // e se não tiver nenhum elemento na fila?
+            db<PEAMQ>(WRN) << "Chosen não existe, escolhendo " << endl;
+            choose();
+        }
+        return _chosen;
+    }
+
+    void insert(Element *e)
+    {
+        // Se é primeiro a ser inserido -> chosen vai ser ele mesmo
+        db<PEAMQ>(WRN) << "Inserindo: " << e->object() << " na fila " << e->rank().queue_eamq() << endl;
+        if (_list[e->rank().queue_eamq()].empty() && !_chosen) {
+            _chosen = e;
+        } else {
+            
+            if (_list[e->rank().queue_eamq()].empty() ) {
+                _occupied_queues++;
+            }
+
+            _list[e->rank().queue_eamq()].insert(e);
+            _total_size++;
+        }
+
+    }
+
+    Element *remove(Element *e)
+    {
+        db<PEAMQ>(WRN) << "REMOVENDO: " << e->object() << endl;
+
+        if (e == _chosen)
+        {   
+            db<PEAMQ>(WRN) << "REMOVENDO O CHOSEN" << endl;
+            // Se a fila não estiver vazia
+            if (_list[R::current_queue_eamq()].size() > 0)
+            {
+                db<PEAMQ>(WRN) << "Vamos colocar alguem no chosen da fila " << R::current_queue_eamq() << endl;
+                // adicionamos o primeiro elemento para ser o chosen
+                _chosen = _list[R::current_queue_eamq()].remove_head();
+                db<PEAMQ>(WRN) << "Novo chosen: " << _chosen->object() << endl;
+                _total_size--;
+
+                // Se agora a fila ficou vazia
+                if (_list[R::current_queue_eamq()].size() == 0)
+                {
+                    // diminuimos a quantidade de filas ocupadas
+                    _occupied_queues--;
+                }
+
+            } else {
+                // caso já não tenha ninguém naquela fila o chosen é 0
+                // temos que ver onde cada remove acontece, 
+                // pois o current_queue_eamq() PRECISA ESTAR ATUALIZADO PARA UMA FILA COM THREADS
+
+                // EM OUTRAS PALAVRAS, ESTE ELSE NUNCA DEVE SER EXECUTADO
+                _chosen = 0;
+                return e;
+            }
+
+            return e;
+        }
+
+        _total_size--;
+        if (_list[e->rank().queue_eamq()].size() == 1)
+            _occupied_queues--;
+
+        db<PEAMQ>(WRN) << "Não é chosen, tirando da fila: " << e->rank().queue_eamq() << endl;
+        return _list[e->rank().queue_eamq()].remove(e);
+    }
+
+    Element *choose()
+    {
+        db<PEAMQ>(WRN) << "CHOOSE" << endl;
+
+        if (empty() && !_chosen)
+        {
+            db<PEAMQ>(WRN) << "CHOOSE - NAOOOO" << endl;
+            // rezando para dar erro
+            // _chosen já é 0
+            return 0;
+        }
+
+        if (!empty())
+        {
+            db<PEAMQ>(WRN) << "CHOOSE - Tem na fila ainda" << endl;
+            if (_chosen) {
+                Element * tmp = _chosen;
+               _list[tmp->rank().queue_eamq()].insert(tmp);
+
+               // Se devolvido para uma fila que estava vazia
+               if (_list[tmp->rank().queue_eamq()].size() == 1) {
+                   _occupied_queues++;
+               }
+
+            } else {
+                // se não houver um chosen, escolhemos o primeiro da fila, precisamos subtrair o total_size
+                _total_size--;
+            }
+    
+            // Se a fila estava ocupada com apenas uma thread
+            if (_list[R::current_queue_eamq()].size() == 1) {
+                _occupied_queues--;
+            }
+            _chosen = 0;
+            _chosen = _list[R::current_queue_eamq()].remove_head();
+        }
+        
+        db<PEAMQ>(WRN) << "CHOOSE - Indo retornar: " << _chosen->object() << endl;
+        // caso tenha chosen e a fila vazia apenas devolve o chosen
+        // trata os dois casos
+        return _chosen;
+
+    }
+
+    // TODO: Improve this method
+    // Caso 2 threads chamem esse método na mesma fila uma fica mandando para a outra
+    // basicamente infinitamente... não acho que dê problema em nosso caso ainda
+    Element *choose_another()
+    {
+        db<PEAMQ>(WRN) << "CHOOSE ANOTHER" << endl;
+        // if (!empty() && head()->rank() != R::IDLE)
+        // {
+        //     Element *tmp = _chosen;
+        //     _chosen = Base::remove_head();
+        //     Base::insert(tmp);
+        // }
+
+        // return _chosen;
+
+        if (!empty() && head()->rank() != R::IDLE)
+        {
+            Element *tmp = _chosen;
+            _chosen = _list[R::current_queue_eamq()].remove_head();
+            if (_list[R::current_queue_eamq()].empty())
+                _occupied_queues--;
+            
+            _list[tmp->rank().queue_eamq()].insert(tmp);
+            if (_list[tmp->rank().queue_eamq()].size() == 1)
+                _occupied_queues++;
+        }
+
+        return _chosen;
+
+        // //if (chosen()->rank()->queue_eamq() != R::current_queue_eamq())
+        // _chosen = _list[R::current_queue_eamq()].head()->next();
+        // return _chosen;
+    }
+
+    Element *choose(Element *e)
+    {
+        db<PEAMQ>(WRN) << "CHOOSE P" << endl;
+        // if (e != _chosen)
+        // {
+        //     Base::insert(_chosen);
+        //     _chosen = Base::remove(e);
+        // }
+
+        // return _chosen;
+        if (!_chosen) {
+            _total_size--;
+        }
+
+        if (e != _chosen)
+        {
+            if (_chosen)
+                _list[chosen()->rank().queue_eamq()].insert(_chosen);
+
+            _chosen = _list[e->rank().queue_eamq()].remove(e);
+        }
+
+        return _chosen;
+        // _chosen = e;
+        // return _chosen;
+    }
+
+private:
+    L _list[Q];
+    // using Base::remove;
+    unsigned int _total_size;
+    unsigned int _occupied_queues; 
+    Element *volatile _chosen;
+};
 
 // Doubly-Linked, Multihead Scheduling List
 // Besides declaring "Criterion", objects subject to scheduling policies that
 // use the Multihead list must export the HEADS constant to indicate the
 // number of heads in the list and the current_head() class method to designate
 // the head to which the current operation applies.
-template<typename T,
+template <typename T,
           typename R = typename T::Criterion,
           typename El = List_Elements::Doubly_Linked_Scheduling<T, R>,
           unsigned int H = R::HEADS>
-class Multihead_Scheduling_List: private Ordered_List<T, R, El>
+class Multihead_Scheduling_List : private Ordered_List<T, R, El>
 {
-    template<typename FT, typename FR, typename FEl, typename FL, unsigned int FQ>
-    friend class Scheduling_Multilist;          // for chosen() and remove()
+    template <typename FT, typename FR, typename FEl, typename FL, unsigned int FQ>
+    friend class Scheduling_Multilist; // for chosen() and remove()
 
 private:
     typedef Ordered_List<T, R, El> Base;
@@ -1167,65 +1530,77 @@ public:
     typedef typename Base::Iterator Iterator;
 
 public:
-    Multihead_Scheduling_List() {
-        for(unsigned int i = 0; i < H; i++)
+    Multihead_Scheduling_List()
+    {
+        for (unsigned int i = 0; i < H; i++)
             _chosen[i] = 0;
     }
 
+    using Base::begin;
     using Base::empty;
-    using Base::size;
+    using Base::end;
     using Base::head;
+    using Base::size;
     using Base::tail;
-    using Base::begin;
-    using Base::end;
 
-    Element * volatile & chosen() { return _chosen[R::current_head()]; }
-    Element * volatile & chosen(unsigned int head) { return _chosen[head]; }
+    Element *volatile &chosen() { return _chosen[R::current_head()]; }
+    Element *volatile &chosen(unsigned int head) { return _chosen[head]; }
 
-    void insert(Element * e) {
-        db<Lists>(TRC) << "Scheduling_List::insert(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
-                       << "}" << endl;
+    void insert(Element *e)
+    {
 
-        if(_chosen[R::current_head()])
+        if (_chosen[R::current_head()])
             Base::insert(e);
         else
             _chosen[R::current_head()] = e;
+        
+        db<Lists>(WRN) << "Scheduling_List::insert(e=" << e
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
+                       << "}" << " queue: " << (e->rank().queue()) << endl;
     }
 
-    Element * remove(Element * e) {
+    Element *remove(Element *e)
+    {
         db<Lists>(TRC) << "Scheduling_List::remove(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
-
-        if(e == _chosen[R::current_head()])
+        //db<GEAMQ>(WRN) << "TENTANTO REMOVER DO CPU" << R::current_head() << endl;
+        if (e == _chosen[R::current_head()]) {
+            //db<GEAMQ>(WRN) << "REMOVENDO CHOSEN!! -> " << _chosen[R::current_head()] << endl;
             _chosen[R::current_head()] = Base::remove_head();
-        else
-            e = Base::remove(e);
+            //db<GEAMQ>(WRN) << "CHOSEN NOVO-> " << _chosen[R::current_head()] << endl;
+            }
+        else {
+            //db<GEAMQ>(WRN) << "REMOVENDO DA LISTA??" << endl;
+            e = Base::remove(e);}
 
         return e;
     }
 
-    Element * choose() {
+    Element *choose()
+    {
         db<Lists>(TRC) << "Scheduling_List::choose()" << endl;
 
-        if(!empty()) {
+        if (!empty())
+        {
             Base::insert(_chosen[R::current_head()]);
             _chosen[R::current_head()] = Base::remove_head();
         }
-
+        //db<Lists>(WRN) << "CHOOSE MULTIHEAD: " << _chosen[R::current_head()] << endl;
         return _chosen[R::current_head()];
     }
 
-    Element * choose_another() {
+    Element *choose_another()
+    {
         db<Lists>(TRC) << "Scheduling_List::choose_another()" << endl;
 
-        if(!empty() && head()->rank() != R::IDLE) {
-            Element * tmp = _chosen[R::current_head()];
+        if (!empty() && head()->rank() != R::IDLE)
+        {
+            Element *tmp = _chosen[R::current_head()];
             _chosen[R::current_head()] = Base::remove_head();
             Base::insert(tmp);
         }
@@ -1233,14 +1608,16 @@ public:
         return _chosen[R::current_head()];
     }
 
-    Element * choose(Element * e) {
+    Element *choose(Element *e)
+    {
         db<Lists>(TRC) << "Scheduling_List::choose(e=" << e
-                       << ") => {p=" << (e ? e->prev() : (void *) -1)
-                       << ",o=" << (e ? e->object() : (void *) -1)
-                       << ",n=" << (e ? e->next() : (void *) -1)
+                       << ") => {p=" << (e ? e->prev() : (void *)-1)
+                       << ",o=" << (e ? e->object() : (void *)-1)
+                       << ",n=" << (e ? e->next() : (void *)-1)
                        << "}" << endl;
 
-        if(e != _chosen[R::current_head()]) {
+        if (e != _chosen[R::current_head()])
+        {
             Base::insert(_chosen[R::current_head()]);
             _chosen[R::current_head()] = Base::remove(e);
         }
@@ -1250,20 +1627,19 @@ public:
 
 private:
     using Base::remove;
-    void chosen(Element * e) { _chosen[R::current_head()] = e; }
+    void chosen(Element *e) { _chosen[R::current_head()] = e; }
 
 private:
-    Element * volatile _chosen[H];
+    Element *volatile _chosen[H];
 };
 
-
 // Doubly-Linked, Scheduling Multilist
 // Besides declaring "Criterion", objects subject to scheduling policies that
 // use the Multilist must export the QUEUES constant to indicate the number of
 // sublists in the list, the current_queue() class method to designate the
 // queue to which the current operation applies, and the queue() method to
 // return the queue in which the object currently resides.
-template<typename T,
+template <typename T,
           typename R = typename T::Criterion,
           typename El = List_Elements::Doubly_Linked_Scheduling<T, R>,
           typename L = Scheduling_List<T, R, El>,
@@ -1280,59 +1656,99 @@ public:
     Scheduling_Multilist() {}
 
     bool empty() const { return _list[R::current_queue()].empty(); }
+    bool empty(unsigned int queue) { return _list[queue].empty(); }
 
     unsigned long size() const { return _list[R::current_queue()].size(); }
     unsigned long size(unsigned int queue) const { return _list[queue].size(); }
 
-    unsigned long total_size() const {
+    unsigned long total_size() const
+    {
         unsigned long s = 0;
-        for(unsigned int i = 0; i < Q; i++)
+        for (unsigned int i = 0; i < Q; i++)
             s += _list[i].size();
         return s;
     }
 
-    Element * head() { return _list[R::current_queue()].head(); }
-    Element * tail() { return _list[R::current_queue()].tail(); }
+    Element *head() { return _list[R::current_queue()].head(); }
+    Element *head(unsigned int i) { return _list[i].head(); }
+    Element *tail() { return _list[R::current_queue()].tail(); }
+    Element *tail(unsigned int i) { return _list[i].tail(); }
 
     Iterator begin() { return Iterator(_list[R::current_queue()].head()); }
     Iterator begin(unsigned int queue) { return Iterator(_list[queue].head()); }
     Iterator end() { return Iterator(0); }
+    Iterator end(unsigned int queue) { return Iterator(_list[queue].tail()); }
+
+    // Quantidade de filas ocupadas em determinado momento baseado em seu próprio chosen / fila com threads
+    // Usado em round_profile, não liga para threads escolhidas por outros cores
+    const int occupied_queues() { 
+        int count = 0;
+        for (unsigned int i = 0; i < Q; i++) {
+            if (_list[i].chosen() || !_list[i].empty()) {
+                count++;
+            }
+        }
+        return count;
+    }
 
-    Element * volatile & chosen() {
+    Element *volatile &chosen()
+    {
+        //db<Lists>(WRN) << "Pegando CHOSEN da fila" << R::current_queue() << " : " << _list[R::current_queue()].chosen() << endl;
         return _list[R::current_queue()].chosen();
     }
-    Element * volatile & chosen(unsigned int queue) {
+    
+    Element *volatile &chosen(unsigned int queue)
+    {
+        return _list[queue].chosen();
+    }
+
+    // workaround para escolher o chosen sem passar
+    Element *volatile &chosen_now(unsigned int queue)
+    {
         return _list[queue].chosen();
     }
 
-    void insert(Element * e) {
+    void insert(Element *e)
+    {
+        // if (_list[e->rank().queue()].empty() && e->rank() != -1) {
+        //     _list[e->rank().queue()].insert_bruh(e);
+        // }
         _list[e->rank().queue()].insert(e);
     }
 
-    Element * remove(Element * e) {
-         return _list[e->rank().queue()].remove(e);
-     }
+    Element *remove(Element *e)
+    {
+        db<GEAMQ>(TRC) << "e->rank().queue() " << e->rank().queue() << " current_queue " << R::current_queue() << endl;
+        return _list[e->rank().queue()].remove(e);
+    }
 
-    Element * choose() {
-    	if(_list[R::current_queue()].chosen()->rank().queue() != R::current_queue()) {
+    Element *choose()
+    {
+        if (_list[R::current_queue()].chosen()->rank().queue() != R::current_queue())
+        {
             insert(_list[R::current_queue()].chosen());
             _list[R::current_queue()].chosen(_list[R::current_queue()].remove());
-    	}
+        }
+        //db<Lists>(WRN) << "CHOOSE MULTILIST - current queue: " << R::current_queue() << endl;
 
-    	return _list[R::current_queue()].choose();
+        return _list[R::current_queue()].choose();
     }
 
-    Element * choose_another() {
-        if(_list[R::current_queue()].chosen()->rank().queue() != R::current_queue()) {
+    Element *choose_another()
+    {
+        if (_list[R::current_queue()].chosen()->rank().queue() != R::current_queue())
+        {
             insert(_list[R::current_queue()].chosen());
             _list[R::current_queue()].chosen(_list[R::current_queue()].remove());
         }
 
-    	return _list[R::current_queue()].choose_another();
+        return _list[R::current_queue()].choose_another();
     }
 
-    Element * choose(Element * e) {
-        if(_list[R::current_queue()].chosen()->rank().queue() != R::current_queue()) {
+    Element *choose(Element *e)
+    {
+        if (_list[R::current_queue()].chosen()->rank().queue() != R::current_queue())
+        {
             insert(_list[R::current_queue()].chosen());
             _list[R::current_queue()].chosen(_list[R::current_queue()].remove());
         }
@@ -1352,17 +1768,186 @@ private:
 // queue to which the current operation applies, the current_head() class
 // method to designate the head to which the current operation applies, and
 // the queue() method to return the queue in which the object currently resides.
-template<typename T,
+template <typename T,
           typename R = typename T::Criterion,
           typename El = List_Elements::Doubly_Linked_Scheduling<T, R>,
           unsigned int Q = R::QUEUES,
           unsigned int H = R::HEADS>
-class Multihead_Scheduling_Multilist: public Scheduling_Multilist<T, R, El, Multihead_Scheduling_List<T, R, El, H>, Q> {};
+class Multihead_Scheduling_Multilist : public Scheduling_Multilist<T, R, El, Multihead_Scheduling_List<T, R, El, H>, Q>
+{
+};
+
+
+// // Estrutura nova para multicore particionado 
+// template <typename T,
+//           typename PR = typename T::Criterion,
+//           typename R = typename T::Criterion,
+//           typename E = List_Elements::Doubly_Linked_Scheduling<T, PR>,
+//           typename El = List_Elements::Doubly_Linked_Scheduling<T, R>,
+//           unsigned int Q = R::QUEUES,
+//           unsigned int QM = PR::QUEUES_CORES,
+//           typename LI = Scheduling_List<T, R, El>,
+//           typename L = Scheduling_Multilist_Single_Chosen<T, R, El, LI, Q>>
+// class Multilist_Scheduling_Multilist : public Scheduling_Multilist<T, PR, E, L, QM>
+// {
+// public:
+//     typedef T Object_Type;
+//     typedef R Rank_Type;
+//     typedef El Element;
+//     typedef typename L::Iterator Iterator;
+
+// public:
+//     Element *choose()
+//     {
+//         if (_list[R::current_queue()].chosen()->rank().queue() != R::current_queue())
+//         {
+//             insert(_list[R::current_queue()].chosen());
+//             _list[R::current_queue()].chosen(_list[R::current_queue()][PR::current_queue_eamq()].remove());
+//         }
+//         //db<Lists>(WRN) << "CHOOSE MULTILIST - current queue: " << R::current_queue() << endl;
+
+//         return _list[R::current_queue()].choose();
+//     }
+
+//     Element *choose_another()
+//     {
+//         if (_list[R::current_queue()].chosen()->rank().queue() != R::current_queue())
+//         {
+//             insert(_list[R::current_queue()].chosen());
+//             _list[R::current_queue()].chosen(_list[R::current_queue()][PR::current_queue_eamq()].remove());
+//         }
+
+//         return _list[R::current_queue()].choose_another();
+//     }
+
+//     Element *choose(Element *e)
+//     {
+//         if (_list[R::current_queue()].chosen()->rank().queue() != R::current_queue())
+//         {
+//             insert(_list[R::current_queue()].chosen());
+//             _list[R::current_queue()].chosen(_list[R::current_queue()][PR::current_queue_eamq()].remove());
+//         }
+
+//         return _list[e->rank().queue()].choose(e);
+//     }
+
+// private:
+//     L _list[QM];
+// };
+
+// Estrutura nova para multicore particionado 
+template <typename T,
+          typename R = typename T::Criterion,
+          typename El = List_Elements::Doubly_Linked_Scheduling<T, R>,
+          unsigned int Q = R::QUEUES,
+          unsigned int QM = R::QUEUES_CORES,
+          typename LI = Ordered_List<T, R, El>,
+          typename L = Scheduling_Multilist_Single_Chosen<T, R, El, LI, Q>>
+class Multilist_Scheduling_Multilist
+{
+public:
+    typedef T Object_Type;
+    typedef R Rank_Type;
+    typedef El Element;
+    typedef typename L::Iterator Iterator;
+
+public:
+    Multilist_Scheduling_Multilist() {}
+
+    bool empty() const { return _list[R::current_queue()].empty(); }
+    bool empty(unsigned int queue) { return _list[queue].empty(); }
+
+    unsigned long size() const { return _list[R::current_queue()].size(); }
+    unsigned long size(unsigned int queue) const { return _list[queue].size(); }
+
+    unsigned long total_size() const
+    {
+        unsigned long s = 0;
+        for (unsigned int i = 0; i < QM; i++)
+            s += _list[i].total_size();
+        return s;
+    }
+
+    Element *head() { return _list[R::current_queue()].head(); }
+    Element *head(unsigned int i) { return _list[i].head(); }
+    Element *tail() { return _list[R::current_queue()].tail(); }
+    Element *tail(unsigned int i) { return _list[i].tail(); }
+    Element *tail(unsigned int i, unsigned int j) { return _list[i].tail(j); }
+
+    Iterator begin() { return Iterator(_list[R::current_queue()].head()); }
+    Iterator begin(unsigned int queue) { return Iterator(_list[queue].head()); }
+    Iterator end() { return Iterator(0); }
+    Iterator end(unsigned int queue) { return Iterator(_list[queue].tail()); }
+
+    // Quantidade de filas ocupadas em determinado momento baseado em seu próprio chosen / fila com threads
+    // Usado em round_profile, não liga para threads escolhidas por outros cores
+    const int occupied_queues() { 
+        int count = 0;
+        for (unsigned int i = 0; i < QM; i++) {
+            if (_list[i].chosen() || !_list[i].empty()) {
+                count++;
+            }
+        }
+        return count;
+    }
+
+    Element *volatile &chosen()
+    {
+        //db<Lists>(WRN) << "Pegando CHOSEN da fila" << R::current_queue() << " : " << _list[R::current_queue()].chosen() << endl;
+        return _list[R::current_queue()].chosen();
+    }
+    
+    Element *volatile &chosen(unsigned int queue)
+    {
+        return _list[queue].chosen();
+    }
+
+    // workaround para escolher o chosen sem passar
+    Element *volatile &chosen_now(unsigned int queue)
+    {
+        return _list[queue].chosen();
+    }
+
+    void insert(Element *e)
+    {
+        // if (_list[e->rank().queue()].empty() && e->rank() != -1) {
+        //     _list[e->rank().queue()].insert_bruh(e);
+        // }
+        db<PEAMQ>(WRN) << "Inserindo no core" << e->rank().queue() << endl;
+        _list[e->rank().queue()].insert(e);
+    }
+
+    Element *remove(Element *e)
+    {
+        db<GEAMQ>(TRC) << "e->rank().queue() " << e->rank().queue() << " current_queue " << R::current_queue() << endl;
+        return _list[e->rank().queue()].remove(e);
+    }
+
+    Element *choose()
+    {
+        return _list[R::current_queue()].choose();
+    }
+
+    Element *choose_another()
+    {
+        return _list[R::current_queue()].choose_another();
+    }
+
+    Element *choose(Element *e)
+    {
+        return _list[e->rank().queue()].choose(e);
+    }
+
+private:
+    L _list[QM];
+};
+
+
 
 // Doubly-Linked, Grouping List
-template<typename T,
-          typename El = List_Elements::Doubly_Linked_Grouping<T> >
-class Grouping_List: public List<T, El>
+template <typename T,
+          typename El = List_Elements::Doubly_Linked_Grouping<T>>
+class Grouping_List : public List<T, El>
 {
 private:
     typedef List<T, El> Base;
@@ -1373,62 +1958,71 @@ public:
     typedef List_Iterators::Bidirecional<El> Iterator;
 
 public:
-    Grouping_List(): _grouped_size(0) {}
+    Grouping_List() : _grouped_size(0) {}
 
-    using Base::empty;
-    using Base::size;
-    using Base::head;
-    using Base::tail;
     using Base::begin;
+    using Base::empty;
     using Base::end;
+    using Base::head;
     using Base::insert_tail;
-    using Base::remove;
-    using Base::search;
     using Base::print_head;
     using Base::print_tail;
+    using Base::remove;
+    using Base::search;
+    using Base::size;
+    using Base::tail;
 
     unsigned long grouped_size() const { return _grouped_size; }
 
-    Element * search_size(unsigned long s) {
-        Element * e = head();
-        if(sizeof(Object_Type) < sizeof(Element))
-            for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
+    Element *search_size(unsigned long s)
+    {
+        Element *e = head();
+        if (sizeof(Object_Type) < sizeof(Element))
+            for (; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next())
+                ;
         else
-            for(; e && (e->size() < s); e = e->next());
+            for (; e && (e->size() < s); e = e->next())
+                ;
         return e;
     }
 
-    void insert_merging(Element * e, Element ** m1, Element ** m2) {
+    void insert_merging(Element *e, Element **m1, Element **m2)
+    {
         db<Lists>(TRC) << "Grouping_List::insert_merging(e=" << e << ")" << endl;
 
         _grouped_size += e->size();
         *m1 = *m2 = 0;
-        Element * r = search(e->object() + e->size());
-        Element * l = search_left(e->object());
-        if(!l) {
+        Element *r = search(e->object() + e->size());
+        Element *l = search_left(e->object());
+        if (!l)
+        {
             insert_tail(e);
         }
-        if(r) {
+        if (r)
+        {
             e->size(e->size() + r->size());
             remove(r);
             *m1 = r;
         }
-        if(l) {
+        if (l)
+        {
             l->size(l->size() + e->size());
             *m2 = e;
         }
     }
 
-    Element * search_decrementing(unsigned long s) {
+    Element *search_decrementing(unsigned long s)
+    {
         db<Lists>(TRC) << "Grouping_List::search_decrementing(s=" << s << ")" << endl;
         print_head();
         print_tail();
 
-        Element * e = search_size(s);
-        if(e) {
+        Element *e = search_size(s);
+        if (e)
+        {
             e->shrink(s);
             _grouped_size -= s;
-            if(!e->size())
+            if (!e->size())
                 remove(e);
         }
 
@@ -1436,9 +2030,11 @@ public:
     }
 
 private:
-    Element * search_left(const Object_Type * obj) {
-        Element * e = head();
-        for(; e && (e->object() + e->size() != obj); e = e->next());
+    Element *search_left(const Object_Type *obj)
+    {
+        Element *e = head();
+        for (; e && (e->object() + e->size() != obj); e = e->next())
+            ;
         return e;
     }
 
diff --git a/include/utility/scheduling.h b/include/utility/scheduling.h
index 41ee114..9ba7742 100644
--- a/include/utility/scheduling.h
+++ b/include/utility/scheduling.h
@@ -15,7 +15,6 @@ __BEGIN_UTIL
 template<typename T, typename R = typename T::Criterion>
 class Scheduling_Queue: public Scheduling_List<T> {};
 
-
 // Scheduler
 // Objects subject to scheduling by Scheduler must declare a type "Criterion"
 // that will be used as the scheduling queue sorting criterion (viz, through
@@ -35,7 +34,7 @@ public:
 public:
     Scheduler() {}
 
-    unsigned int schedulables() { return Base::size(); }
+    unsigned int schedulables() { return Base::total_size(); }
 
     T * volatile chosen() {
     	// If called before insert(), chosen will dereference a null pointer!
@@ -50,61 +49,62 @@ public:
     }
 
     void insert(T * obj) {
-        db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::insert(" << obj << ")" << endl;
+        // db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::insert(" << obj << ")" << endl;
 
         Base::insert(obj->link());
     }
 
     T * remove(T * obj) {
-        db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::remove(" << obj << ")" << endl;
+        // db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::remove(" << obj << ")" << endl;
 
         return Base::remove(obj->link()) ? obj : 0;
     }
 
     void suspend(T * obj) {
-        db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::suspend(" << obj << ")" << endl;
+        // db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::suspend(" << obj << ")" << endl;
 
         Base::remove(obj->link());
     }
 
     void resume(T * obj) {
-        db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::resume(" << obj << ")" << endl;
+        // db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::resume(" << obj << ")" << endl;
 
         Base::insert(obj->link());
     }
 
     T * choose() {
-        db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::choose() => ";
+        // db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::choose() => ";
 
         T * obj = Base::choose()->object();
 
-        db<Scheduler>(TRC) << obj << endl;
+        // db<Scheduler>(TRC) << obj << endl;
 
         return obj;
     }
 
     T * choose_another() {
-        db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::choose_another() => ";
+        // db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::choose_another() => ";
 
         T * obj = Base::choose_another()->object();
 
-        db<Scheduler>(TRC) << obj << endl;
+        // db<Scheduler>(TRC) << obj << endl;
 
         return obj;
     }
 
     T * choose(T * obj) {
-        db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::choose(" << obj;
+        // db<Scheduler>(TRC) << "Scheduler[chosen=" << chosen() << "]::choose(" << obj;
 
         if(!Base::choose(obj->link()))
             obj = 0;
 
-        db<Scheduler>(TRC) << obj << endl;
+        // db<Scheduler>(TRC) << obj << endl;
 
         return obj;
     }
 };
 
+
 __END_UTIL
 
 #endif
diff --git a/src/api/lixo b/src/api/lixo
new file mode 100644
index 0000000..b6ee883
--- /dev/null
+++ b/src/api/lixo
@@ -0,0 +1,518 @@
+MAIN: Hello world!
+CPU: 2 bruh - 0
+CPU: 0 bruh - 2
+CPU: 3 bruh - 1
+CPU: 2 bruh - 3
+CPU: 3 bruh - 4
+CPU: 0 bruh - 5
+CPU: 3 bruh - 7
+CPU: 0 bruh - 8
+CPU: 2 bruh - 6
+11U: 3 bruh - CPU: 0 bruh - 10
+
+CPU: 2 bruh - 9
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 0 com rate: 0 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 0 :<0>
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<CPU: 0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila 1vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+ pogge<0>: Fila: 3 :<0>
+<0>: Pulando threadrs -  aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: A13valiando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0> :<1>
+: Fila: 1
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate CPU: 1 poggers - 14 :<1>
+= 0
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0CPU: >: Fila: 21 poggers :<0>
+ - 15 :<1>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<0>: AvaliCPando Core: 0 :<0U>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = : 0 :<01 poggers - 16>
+<0> :<1>
+: Fila: 1
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+CPU: 1 poggers - 17
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: FiCPU: 1 poggers - 18 :<1>
+la: 2
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: AvalianCPU: 1 poggers - 19 :<1>
+do Core: 1
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+CPU: 1 poggers - 20
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<0>: AvaCPU: 1 poggers - 21 :<1>
+liando Core: 0
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+<0>: Avaliando Core: 0 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Core rate = 50000 :<0>
+<0>: Novo core minimo: 0 com rate: 50000 :<0>
+<0>: Avaliando Core: 1 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apeCPU: 1 poggers - 22 :<1>
+nas aperiódicas Core rate = 0
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Pulando thread aperiodica :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Novo core minimo: 1 com rate: 0 :<0>
+<0>: Avaliando Core: 2 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Avaliando Core: 3 :<0>
+<0>: Fila: 0 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 1 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 2 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Fila: 3 :<0>
+<0>: Fila vazia / apenas aperiódicas Core rate = 0 :<0>
+<0>: Core escolhido: 1 :<0>
+CPU: 1 poggers - 23
+CPU: 0 poggers - 12
+CPU: 1 poggers - 15
+CPU: 1 poggers - 13
+CPU: 1 poggers - 16
+CPU: 1 poggers - 17
+CPU: 1 poggers - 14
+CPU: 1 poggers - 18
+CPU: 1 poggers - 19
+CPU: 1 poggers - 23
+CPU: 1 poggers - 21
+CPU: 1 poggers - 20
+CPU: 0 poggers - 12
+CPU: 1 poggers - 22
\ No newline at end of file
diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
index 376f77b..2ffe250 100644
--- a/src/api/scheduler.cc
+++ b/src/api/scheduler.cc
@@ -1,17 +1,681 @@
+
 // EPOS CPU Scheduler Component Implementation
 
 #include <process.h>
 #include <time.h>
+#include <utility/random.h>
+#include "scheduler.h"
+
 
 __BEGIN_SYS
 
+inline RT_Common::Tick RT_Common::elapsed() { return Alarm::elapsed(); }
+
+RT_Common::Tick RT_Common::ticks(Microsecond time) {
+    return Timer_Common::ticks(time, Alarm::timer()->frequency());
+}
+
+Microsecond RT_Common::time(Tick ticks) {
+    return Timer_Common::time(ticks, Alarm::timer()->frequency());
+}
+
+void RT_Common::handle(Event event) {
+    db<Thread>(TRC) << "RT::handle(this=" << this << ",e=";
+    if(event & CREATE) {
+        db<Thread>(TRC) << "CREATE";
+
+        _statistics.thread_creation = elapsed();
+        _statistics.job_released = false;
+    }
+    if(event & FINISH) {
+        db<Thread>(TRC) << "FINISH";
+
+        _statistics.thread_destruction = elapsed();
+    }
+    if(event & ENTER) {
+        db<Thread>(TRC) << "ENTER";
+
+        _statistics.thread_last_dispatch = elapsed();
+    }
+    if(event & LEAVE) {
+        Tick cpu_time = elapsed() - _statistics.thread_last_dispatch;
+
+        db<Thread>(TRC) << "LEAVE";
+
+        _statistics.thread_last_preemption = elapsed();
+        _statistics.thread_execution_time += cpu_time;
+        //        if(_statistics.job_released) {
+        _statistics.job_utilization += cpu_time;
+        //        }
+    }
+    if(periodic() && (event & JOB_RELEASE)) {
+        db<Thread>(TRC) << "RELEASE";
+
+        _statistics.job_released = true;
+        _statistics.job_release = elapsed();
+        _statistics.job_start = 0;
+        _statistics.job_utilization = 0;
+        _statistics.jobs_released++;
+    }
+    if(periodic() && (event & JOB_FINISH)) {
+        db<Thread>(TRC) << "WAIT";
+
+        _statistics.job_released = false;
+        _statistics.job_finish = elapsed();
+        _statistics.jobs_finished++;
+        //        _statistics.job_utilization += elapsed() - _statistics.thread_last_dispatch;
+    }
+    if(event & COLLECT) {
+        db<Thread>(TRC) << "|COLLECT";
+    }
+    if(periodic() && (event & CHARGE)) {
+        db<Thread>(TRC) << "|CHARGE";
+    }
+    if(periodic() && (event & AWARD)) {
+        db<Thread>(TRC) << "|AWARD";
+    }
+    if(periodic() && (event & UPDATE)) {
+        db<Thread>(TRC) << "|UPDATE";
+    }
+    db<Thread>(TRC) << ") => {i=" << _priority << ",p=" << _period << ",d=" << _deadline << ",c=" << _capacity << "}" << endl;
+}
+
+//P3 - Alteração
 volatile unsigned int Variable_Queue_Scheduler::_next_queue;
 
 // The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
 template <typename ... Tn>
 FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
-
-// Since the definition above is only known to this unit, forcing its instantiation here so it gets emitted in scheduler.o for subsequent linking with other units is necessary.
 template FCFS::FCFS<>(int p);
 
+/////////////////////////////// P2 - Single core /////////////////////////////// 
+//volatile unsigned EAMQ::_current_queue = QUEUES - 1;
+volatile unsigned int EAMQ::_current_queue[Traits<Machine>::CPUS] = {QUEUES - 1};
+volatile unsigned int GEAMQ::_current_queue[GEAMQ::HEADS] = {QUEUES - 1}; // apenas inicializa o core 0
+bool GEAMQ::initialized = false; // workaround para fazer uma lazy initialization no _current_queue
+bool EAMQ::initialized = false;
+
+// Construtor para threads aperiódicas
+EAMQ::EAMQ(int p) : RT_Common(p), _is_recent_insertion(false), _personal_statistics{}, _behind_of(nullptr), _periodic(false)
+{
+    EAMQ::initialize_current_queue();
+//    if (Traits<System>::RUN_TO_HALT) {
+//        _queue_eamq = 0;
+//        return;
+//    }
+
+    // Coloca thread MAIN e IDLE na mesma fila (fila com menor frequência possível)
+    // prioridade igual a LOW ou mais baixos
+    if (p == MAIN || p == IDLE || p >= LOW) {
+        if (p == MAIN) {db<PEAMQ>(WRN) << "CRIOU MAIN" << endl;}
+        if (p == IDLE) {db<PEAMQ>(WRN) << "CRIOU IDLE" << endl;}
+        _queue_eamq = QUEUES - 1;
+    } else {
+        // Se a prioridade é NORMAL ou HIGH (p < LOW)
+        _queue_eamq = QUEUES - 2;
+    }
+    
+}
+
+// PERIODIC passado para RT_Common pois logo em seguida ele é atualizado
+EAMQ::EAMQ(Microsecond p, Microsecond d, Microsecond c) : RT_Common(PERIODIC, p, d, c), _is_recent_insertion(false), _personal_statistics{}, _behind_of(nullptr), _periodic(true)
+{
+
+    db<PEAMQ>(WRN) << "ranking with p: " << p << endl;
+    d = (d ? d : p);
+
+    //int unsigned rand = 3u + (unsigned(Random::random()) % 8u);
+
+    _personal_statistics.remaining_deadline = d;
+    for (unsigned int q = 0; q < QUEUES; q++)
+    {
+        // initial ET estimation (1/3 of deadline)
+        _personal_statistics.average_et[q] = Timer_Common::sim(c ? c : Microsecond(d / 10), CPU::max_clock(), frequency_within(q));
+        _personal_statistics.job_estimated_et[q] = _personal_statistics.average_et[q];
+        // Atualiza tempo de execução restante para EET
+        _personal_statistics.remaining_et[q] = _personal_statistics.job_estimated_et[q];
+    }
+
+    rank_eamq();
+    db<EAMQ>(TRC) << "ranked with: " << _priority << " on queue: " << _queue_eamq << endl;
+}
+
+void EAMQ::handle(Event event) {
+    // Antes de toda troca de threads (choose / chosen) precisa-se avancar 
+    // o ponteiro da fila de escolha 
+    if (event & CHANGE_QUEUE) {
+        unsigned int last = current_queue_eamq();
+        do {
+            // Pula para próxima fila
+            EAMQ::next_queue();
+            db<PEAMQ>(WRN) << "current_queue_eamq: " << current_queue_eamq() << endl;
+        // Enquanto fila atual não vazia ou uma volta completa
+        } while (Thread::scheduler()->empty() && (current_queue_eamq() != last));
+        db<PEAMQ>(WRN) << "CPU " << CPU::id() << " prox: " << current_queue_eamq() << endl;
+
+        // Se for RUN_TO_HALT, não ajusta a frequência (100%)
+        // if (!Traits<System>::RUN_TO_HALT) {
+
+            // Ajustando a frequência conforme a fila
+            Hertz f = frequency_within(current_queue_eamq());
+            CPU::clock(f);
+            
+            // So that IDLE doesnt spam this
+            if (last != current_queue_eamq()) {
+                db<EAMQ>(TRC) << "[!!!] Operating next queue, in frequency: " << f / 1000000 << "Mhz " << "Queue: " << current_queue_eamq() << endl;
+            }
+        // }
+        db<PEAMQ>(WRN) << "HEAD: " << Thread::scheduler()->head()->object() << ", TAIL: " << Thread::scheduler()->tail()->object() << endl;
+    }
+    if (event & CREATE) {
+        db<PEAMQ>(WRN) << "CRIANDO THREAD" << endl;
+        // for (int q = 0; q < QUEUES; q++) {
+        //     db<EAMQ>(WRN) << "CPU " << CPU::id() << " Fila " << q << ": ";
+        //     for (auto it = Thread::scheduler()->end(q); &(*it) != nullptr; it = it->prev()) {
+        //         db<EAMQ>(WRN) << it << " ";
+        //     }
+        //     db<EAMQ>(WRN) << "CPU " << CPU::id() << " CHOSEN: " << Thread::scheduler()->chosen_now(q);
+        // db<EAMQ>(WRN) << endl;
+        // }
+
+        // db<PEAMQ>(WRN) << Thread::scheduler()->occupied_queues() << endl;
+        // for (unsigned long q = 0; q < QUEUES; q++) {
+        //     db<PEAMQ>(WRN) << "Chosen: " << Thread::scheduler()->chosen_now(q) << endl;
+        //     db<PEAMQ>(WRN) << "Core" << q << " tem " << Thread::scheduler()->size(q) << endl;
+        // }
+        // db<PEAMQ>(WRN) << endl;
+
+    }
+    if (event & UPDATE) {
+        db<PEAMQ>(WRN) << "UPDATE" <<endl;
+        // Depois da proxima ser definida e avisada de sua entrada, podemos desproteger as recem entradas
+        // Todas as threads recebem um evento UPDATE
+        _is_recent_insertion = false;
+        _behind_of = nullptr;
+    }
+    // Quando acontece prempcao do quantum
+    if (periodic() && (event & UPDATE)) {
+        if (Q > Time_Base(_personal_statistics.remaining_deadline)) {
+            // underflow
+            _personal_statistics.remaining_deadline = Microsecond(0);
+            // somehow discard this thread
+        } else {
+            // Decrementa do deadline o quantum executado
+            _personal_statistics.remaining_deadline -= Microsecond(Q);
+        }
+    }
+    if (periodic() && (event & CREATE)) {
+        db<PEAMQ>(WRN) << "CRIANDO PERIODICO" <<endl;
+        // Se foi inserido no meio da fila (ou seja, se tem t_fitted)
+        if (_behind_of) {
+            // Faz atualização de rank da thread que foi inserida chamando assure_behind
+            _behind_of->link()->prev()->object()->for_all_behind(ASSURE_BEHIND);
+        }
+    }
+    if (periodic() && (event & LEAVE)) {
+        db<PEAMQ>(WRN) << "LEAVE PERIODICO" <<endl;
+        // Guarda o tempo que passou depois que começou a execução da tarefa
+        Microsecond in_cpu = time(elapsed() - _personal_statistics.job_enter_tick);
+        _personal_statistics.job_execution_time += in_cpu;
+        for (unsigned int q = 0; q < QUEUES; q++)
+        {
+            // Reduz o tempo executado deste quantum, transformando Tick em Microsecond
+            Microsecond executed_in_profile = Timer_Common::sim(in_cpu, frequency_within(_queue_eamq), frequency_within(q));
+            if (executed_in_profile > _personal_statistics.remaining_et[q]) {
+                // underflow
+                _personal_statistics.remaining_et[q] = 0;
+            } else {
+                _personal_statistics.remaining_et[q] -= executed_in_profile;
+            }
+        }
+    }
+    // Quando uma thread periodica começa a tarefa
+    if (periodic() && (event & ENTER)) {
+        db<PEAMQ>(WRN) << "ENTER PERIODICO" <<endl;
+        _personal_statistics.job_enter_tick = elapsed();
+    }
+    // Quando uma thread foi liberado para executar tarefa
+    if (periodic() && (event & JOB_RELEASE)) {
+        db<PEAMQ>(WRN) << "RELEASE PERIODICO" <<endl;
+        _personal_statistics.job_execution_time = 0;
+        rank_eamq();
+    }
+    // Quando uma thread periodica termina tarefa
+    if (periodic() && (event & JOB_FINISH)) {
+        db<PEAMQ>(WRN) << "FINISH PERIODICO" <<endl;
+        for (auto it = Thread::scheduler()->begin(); it != Thread::scheduler()->end(); ++it) {
+            unsigned new_rank = it->rank() - (_personal_statistics.average_et[it->object()->criterion().current_queue_eamq()] + Thread::scheduler()->chosen()->priority());
+            it->rank(new_rank);
+        }
+        if ( Thread::scheduler()->end()) {
+            unsigned new_rank = Thread::scheduler()->end()->rank() + (_personal_statistics.average_et[Thread::scheduler()->end(current_queue_eamq())->object()->criterion().current_queue_eamq()] + Thread::scheduler()->chosen()->priority());
+            Thread::scheduler()->end()->rank(new_rank);
+        }
+
+        
+        for (unsigned int q = 0; q < QUEUES; q++)
+        {
+            // (tempo de execução anterior + tempo de execução atual) / 2
+            _personal_statistics.average_et[q] = (_personal_statistics.average_et[q] + _personal_statistics.job_execution_time) / 2;
+            // Atualiza EET da tarefa para cada fila (relativo a frequência)
+            _personal_statistics.job_estimated_et[q] = Timer_Common::sim(_personal_statistics.average_et[q], frequency_within(_queue_eamq), frequency_within(q));
+            // Timer_Common::time(_personal_statistics.average_et[q], frequency_within(q));
+        }
+        _personal_statistics.job_execution_time = 0;
+    }
+    if (periodic() && (event & ASSURE_BEHIND)) {
+        db<EAMQ>(TRC) << "p: " << _priority << " visited for rerank (someone in front was inserted)" << endl;
+    }
+    if (periodic() && (event & RESUME_THREAD)) {
+        rank_eamq(); // atualiza o rank
+        if (_behind_of) {
+            // Faz atualização de rank da thread que foi inserida chamando assure_behind
+            _behind_of->link()->prev()->object()->for_all_behind(ASSURE_BEHIND);
+        }
+    }
+
+    /* a = new Job()        -> JOB_RELEASE, CREATE
+     * [b] premptado por [a] -> ENTER (a), LEAVE (b)
+     * a acabou tarefa :(    -> JOB_FINISH
+     * a tem nova tarefa >:) -> JOB_RELEASE
+     */
+}
+
+Thread * EAMQ::search_t_fitted(unsigned int q)
+{
+    for (auto it = Thread::scheduler()->end(q); it != Thread::scheduler()->begin(q) && !it->object()->criterion().is_recent_insertion(); it = it->prev()) {
+        Thread * thread_in_queue = it->object();
+        // As ultimas threads da fila tendem a ser aperiodicas, então nós não queremos recalcular o rank delas
+        if (!thread_in_queue->criterion().periodic()) { 
+            //db<EAMQ>(TRC) << "Pulando uma thread aperiodica" << endl;
+            continue;
+        }
+
+        // Thread da frente -> Tf
+        // Thread que será inserido -> Ti
+        int thread_capacity_remaining = thread_in_queue->criterion().personal_statistics().remaining_et[q];
+        int total_time_execution = thread_in_queue->priority()                  // tempo de espera da (Tf)
+                                    + (thread_capacity_remaining * 115 / 100)   // tempo de execução da (Tf)
+                                    + _personal_statistics.remaining_et[q]      // tempo de execução (Ti)
+                                    + estimate_rp_waiting_time(q);              // tempo de espera por RP (Ti)
+
+        if (total_time_execution < int(Time_Base(_personal_statistics.remaining_deadline))) {
+            return thread_in_queue;
+            // vai inserir na frente de alguem, entao salvar onde
+        }
+    }
+    return nullptr;
+}
+
+int EAMQ::rank_eamq() {
+    // Baseado em Choosen não saindo da fila
+    for (int i = QUEUES - 1; i >= 0; i--) {
+        // tempo de execução restante estimado
+        int eet_remaining = _personal_statistics.remaining_et[i];
+        
+        db<EAMQ>(TRC) << "EET restante: " << eet_remaining << endl;
+
+        // calcula round profile waiting time
+        int rp_waiting_time = estimate_rp_waiting_time(i);
+        db<EAMQ>(TRC) << "RP waiting time: " << rp_waiting_time << endl;
+
+
+        // Não avaliamos a possibilidade de inserir threads na frente de outras recém inseridas para evitarmos um possível loop infinito
+        Thread * t_fitted = search_t_fitted(i);
+
+        // Se não encontrou nenhuma fila (não vazia) que cabe a thread (e tem threads periodicas) avalie a próxima
+        if (!t_fitted && !Thread::scheduler()->empty(i) && Thread::scheduler()->head(i)->object()->criterion().periodic()) {
+            continue;
+        }
+
+        _behind_of = t_fitted;
+
+        // forma de accesar a cabeça e checar se é periodica
+        // Thread::scheduler()->head(i)->object()->criterion().periodic()
+
+        // Se a fila estiver vazia t_fitted = NULL
+        int t_fitted_capacity_remaining = 0;
+
+        // Se a fila não estiver vazia precisamos levar em consideração o tempo que a thread da frente esperará
+        if (!Thread::scheduler()->empty(i) && Thread::scheduler()->head(i)->object()->criterion().periodic()) {
+            db<EAMQ>(TRC) << "Fila não vazia e achou fila inserir!" << endl;
+            t_fitted_capacity_remaining = t_fitted->criterion().personal_statistics().remaining_et[i];
+        }
+
+        int cwt_profile = rp_waiting_time + (t_fitted ? t_fitted->priority() + t_fitted_capacity_remaining : 0);
+        int available_time_to_run = _personal_statistics.remaining_deadline - cwt_profile;
+        int idle_time = available_time_to_run - eet_remaining;
+        db<EAMQ>(TRC) << "CWT: " << cwt_profile << ", Time to run: " << available_time_to_run << ", IDLE time: " << idle_time << endl;
+
+        if (idle_time >= 0) {
+            set_queue(i);
+            _priority = cwt_profile;
+            db<EAMQ>(TRC) << "Thread inserted in queue " << i << " with priority " << cwt_profile << endl;
+            return 1;
+        }
+    }
+    // Não encontrou lugar na fila e vai inserir na sub-fila com maior frequencia
+    db<EAMQ>(TRC) << "Thread not inserted in any queue" << endl;
+    _priority = 0;
+    set_queue(0);
+    return 0;
+}
+
+int EAMQ::estimate_rp_waiting_time(unsigned int q) {
+    int rp_rounds = _personal_statistics.remaining_et[q] / Q;
+
+    // Se precisar de uma rodada extra com um tamanho 'menor que o Quantum'
+    if (_personal_statistics.remaining_et[q] % Q) {
+        rp_rounds++;
+    }
+
+    int oc = Thread::scheduler()->occupied_queues();
+    oc -= !Thread::scheduler()->empty(q);
+
+    int rp_waiting_time = Q * (oc) * (rp_rounds);
+
+    return rp_waiting_time;
+}
+
+volatile unsigned int PEAMQ::evaluate()
+{
+    unsigned long long min = IDLE;
+    unsigned int chosen_core = 0;
+
+    for (unsigned int core = 0; core < CPU::cores(); core++)
+    {
+        unsigned long long core_rate = 0;
+
+        for (unsigned int q = 0; q < QUEUES; q++)
+        {
+            auto last_element = Thread::scheduler()->tail(core, q);
+            while (last_element && !last_element->object()->criterion().periodic())
+            {
+                last_element = last_element->prev();
+            }
+            
+            if (!last_element)
+            {
+                core_rate += 0;
+            } else {
+                core_rate += last_element->object()->priority() - (((last_element->object()->priority() / 1000) * 125) * q);   // (1 - 0.125 x q)
+            }
+        }
+        if (core_rate < min)
+        {
+            min = core_rate;
+            chosen_core = core;
+        }
+    }
+    return chosen_core;
+}
+
+
+/////////////////////////////// P3 - Multicore Global Scheduling /////////////////////////////// 
+// P3TEST - novo calculo de rank -> precisa alterar rp waiting time ainda tbm 
+// Verificar se todos os cores irão setar para QUEUE - 1
+// volatile unsigned int GEAMQ::_current_queue[GEAMQ::HEADS] = {QUEUES - 1};
+
+// void GEAMQ::handle(Event event) {
+//     // Antes de toda troca de threads (choose / chosen) precisa-se avancar 
+//     // o ponteiro da fila de escolha 
+//     if (event & CHANGE_QUEUE) {
+//         unsigned int last = current_queue();
+//         // db<Thread>(WRN) << "CPU " << CPU::id() << " Last Queue: " << last << endl;
+//         do {
+//             // Pula para próxima fila
+//             GEAMQ::next_queue();
+//             db<Lists>(TRC) << "next_queue chamado, levou para: " << current_queue() << endl;
+//         // Enquanto fila atual não vazia ou uma volta completa
+//         // ACHO que da certo apenas com chosen() 
+//         } while (Thread::scheduler()->empty(current_queue()) && !(Thread::scheduler()->chosen()) && (current_queue() != last));
+
+//         //db<Thread>(WRN) << "Current_queue ATUAL: " << current_queue() << endl;
+
+//         // Se for RUN_TO_HALT, não ajusta a frequência (100%)
+//         if (!Traits<System>::RUN_TO_HALT) {
+//             // Ajustando a frequência conforme a fila
+//             Hertz f = frequency_within(current_queue());
+//             CPU::clock(f);
+            
+//             // So that IDLE doesnt spam this
+//             if (last != current_queue()) {
+//                 db<EAMQ>(TRC) << "[!!!] Operating next queue, in frequency: " << f / 1000000 << "Mhz " << "Queue: " << current_queue() << endl;
+//             }
+//         }
+//     }
+//     if (event & CREATE) {
+//         // // db<Lists>(WRN) << "CRIANDO THREAD" << endl;
+//         //unsigned int count = 5;
+//         // for (int q = 0; q < QUEUES; q++) {
+//         //     db<GEAMQ>(WRN) << "CPU " << CPU::id() << " Fila " << q << " Tamanho  " <<  Thread::scheduler()->size(q) << " ";
+//         //     for (Thread* t = Thread::scheduler()->tail(q)->object(); t != nullptr; t = t->link()->prev()->object()) {
+//         //         //if (count == 0) {break;} 
+//         //         db<GEAMQ>(WRN) << t << " ";
+//         //         //count--;
+//         //     }
+//         //     db<GEAMQ>(WRN) << "CPU " << CPU::id() << " CHOSEN: " << Thread::scheduler()->chosen_now(q)->object();
+//         // db<GEAMQ>(WRN) << endl;
+//         // }
+//         // db<GEAMQ>(WRN) << endl;
+//     }
+//     if (event & UPDATE) {
+//         // Depois da proxima ser definida e avisada de sua entrada, podemos desproteger as recem entradas
+//         // Todas as threads recebem um evento UPDATE
+//         _is_recent_insertion = false;
+//         _behind_of = nullptr;
+//     }
+//     // Quando acontece prempcao do quantum
+//     if (periodic() && (event & UPDATE)) {
+//         if (Q > Time_Base(_personal_statistics.remaining_deadline)) {
+//             // underflow
+//             _personal_statistics.remaining_deadline = Microsecond(0);
+//             // somehow discard this thread
+//         } else {
+//             // Decrementa do deadline o quantum executado
+//             _personal_statistics.remaining_deadline -= Microsecond(Q);
+//         }
+//     }
+//     if (periodic() && (event & CREATE)) {
+//         // Se foi inserido no meio da fila (ou seja, se tem t_fitted)
+//         if (_behind_of) {
+//             // Faz atualização de rank da thread que foi inserida chamando assure_behind
+//             _behind_of->link()->prev()->object()->for_all_behind(ASSURE_BEHIND);
+//         }
+//     }
+//     if (periodic() && (event & LEAVE)) {
+//         // Guarda o tempo que passou depois que começou a execução da tarefa
+//         Microsecond in_cpu = time(elapsed() - _personal_statistics.job_enter_tick);
+//         _personal_statistics.job_execution_time += in_cpu;
+//         for (unsigned int q = 0; q < QUEUES; q++)
+//         {
+//             // Reduz o tempo executado deste quantum, transformando Tick em Microsecond
+//             Microsecond executed_in_profile = Timer_Common::sim(in_cpu, frequency_within(_queue_eamq), frequency_within(q));
+//             if (executed_in_profile > _personal_statistics.remaining_et[q]) {
+//                 // underflow
+//                 _personal_statistics.remaining_et[q] = 0;
+//             } else {
+//                 _personal_statistics.remaining_et[q] -= executed_in_profile;
+//             }
+//         }
+//     }
+//     // Quando uma thread periodica começa a tarefa
+//     if (periodic() && (event & ENTER)) {
+//         _personal_statistics.job_enter_tick = elapsed();
+
+//         // int count = 5;
+//         // for (int q = 0; q < QUEUES; q++) {
+//         //     db<GEAMQ>(WRN) << "CPU " << CPU::id() << " Fila " << q << " Tamanho  " <<  Thread::scheduler()->size(q) << " ";
+//         //     for (Thread* t = Thread::scheduler()->tail(q)->object(); t != nullptr; t = t->link()->prev()->object()) { 
+//         //         db<GEAMQ>(WRN) << t->link() << " ";
+//         //         count--;
+//         //     }
+//         //     count = 5;
+//         //     db<GEAMQ>(WRN) << "CPU " << CPU::id() << " CHOSEN: " << Thread::scheduler()->chosen_now(q);
+//         // db<GEAMQ>(WRN) << endl;
+//         // }
+//         // db<GEAMQ>(WRN) << endl;
+//     }
+//     // Quando uma thread foi liberado para executar tarefa
+//     if (periodic() && (event & JOB_RELEASE)) {
+//         // db<GEAMQ>(INF) << "JOB RELEASE" << endl;
+//         _personal_statistics.job_execution_time = 0;
+//     }
+//     // Quando uma thread periodica termina tarefa
+//     if (periodic() && (event & JOB_FINISH)) {
+//         // Atualiza rank de todas as threads da fila diminuindo o tempo
+//         // db<GEAMQ>(WRN) << "JOB FINISH" << endl;
+//         for (auto it = Thread::scheduler()->begin(current_queue()); it != Thread::scheduler()->end(current_queue()); ++it) {
+//             if (!it->object()->criterion().periodic()) break;
+            
+//             unsigned new_rank = it->rank()
+//                                     - (_personal_statistics.average_et[it->object()->criterion().current_queue()] 
+//                                         + Thread::scheduler()->chosen()->priority());
+//             it->rank(new_rank);
+//         }
+//         // mais uma execução para cobrir o ultimo elemento da fila (fizemos uma bagunca com os end's e begin's possivelmente)
+//         if ( Thread::scheduler()->end(current_queue()) && Thread::scheduler()->end(current_queue())->object()->criterion().periodic() ) {
+//             unsigned new_rank = Thread::scheduler()->end(current_queue())->rank() 
+//                                     + (_personal_statistics.average_et[Thread::scheduler()->end(current_queue())->object()->criterion().current_queue()] 
+//                                         + Thread::scheduler()->chosen()->priority());
+                                        
+//             Thread::scheduler()->end(current_queue())->rank(new_rank);
+//         }
+
+        
+//         for (unsigned int q = 0; q < QUEUES; q++)
+//         {
+//             // (tempo de execução anterior + tempo de execução atual) / 2
+//             _personal_statistics.average_et[q] = (_personal_statistics.average_et[q] + _personal_statistics.job_execution_time) / 2;
+//             // Atualiza EET da tarefa para cada fila (relativo a frequência)
+//             _personal_statistics.job_estimated_et[q] = Timer_Common::sim(_personal_statistics.average_et[q], frequency_within(_queue_eamq), frequency_within(q));
+//             // Timer_Common::time(_personal_statistics.average_et[q], frequency_within(q));
+//         }
+//         _personal_statistics.job_execution_time = 0;
+//     }
+//     if (periodic() && (event & ASSURE_BEHIND)) {
+//         db<GEAMQ>(TRC) << "p: " << _priority << " visited for rerank (someone in front was inserted)" << endl;
+//     }
+//     if (periodic() && (event & RESUME_THREAD)) {
+//         db<GEAMQ>(TRC) << "RESUME_THREAD called, is periodic" << endl;
+
+//         rank_eamq(); // atualiza o rank
+//         if (_behind_of) {
+//             // Faz atualização de rank da thread que foi inserida chamando assure_behind
+//             _behind_of->link()->prev()->object()->for_all_behind(ASSURE_BEHIND);
+//         }
+//     }
+//     if (event & CHARGE) {
+//         // for (int q = 0; q < QUEUES; q++) {
+//         //     db<GEAMQ>(WRN) << " Fila " << q << " Tamanho  " <<  Thread::scheduler()->size(q) << " ";
+//         //     for (Thread* t = Thread::scheduler()->tail(q)->object(); t != nullptr; t = t->link()->prev()->object()) { 
+//         //         db<GEAMQ>(WRN) << t->link() << " ";
+//         //     }
+//         //     db<GEAMQ>(WRN) << endl;
+//         //     db<GEAMQ>(WRN) << "CPU " << CPU::id() << " CHOSEN: " << Thread::scheduler()->chosen_now(q);
+//         // db<GEAMQ>(WRN) << endl;
+//         // }
+//         // db<GEAMQ>(WRN) << endl;
+//     }
+//     /* a = new Job()        -> JOB_RELEASE, CREATE
+//      * [b] premptado por [a] -> ENTER (a), LEAVE (b)
+//      * a acabou tarefa :(    -> JOB_FINISH
+//      * a tem nova tarefa >:) -> JOB_RELEASE
+//      */
+// }
+
+// int GEAMQ::rank_eamq() {
+//     for (int i = QUEUES - 1; i >= 0; i--) {
+//         Thread * t_fitted = nullptr;
+
+//         // tempo de execução restante estimado
+//         int eet_remaining = _personal_statistics.remaining_et[i];
+//         db<GEAMQ>(TRC) << "EET restante: " << eet_remaining << endl;
+
+//         // calcula round profile waiting time
+//         int rp_waiting_time = estimate_rp_waiting_time(i);
+//         db<GEAMQ>(TRC) << "RP waiting time: " << rp_waiting_time << endl;
+
+//         // Não avaliamos a possibilidade de inserir threads na frente de outras recém inseridas para evitarmos um possível loop infinito
+//         for (auto it = Thread::scheduler()->end(i); it != Thread::scheduler()->begin(i) && !it->object()->criterion().is_recent_insertion(); it = it->prev()) {
+//             Thread * thread_in_queue = it->object();
+//             // As ultimas threads da fila tendem a ser aperiodicas, então nós não queremos recalcular o rank delas
+//             if (!thread_in_queue->criterion().periodic()) { 
+//                 db<GEAMQ>(TRC) << "Pulando uma thread aperiodica" << endl;
+//                 continue;
+//             }
+
+//             // Thread da frente -> Tf
+//             // Thread que será inserido -> Ti
+//             int thread_capacity_remaining = thread_in_queue->criterion().personal_statistics().remaining_et[i];
+//             int total_time_execution = thread_in_queue->priority()               // tempo de espera da (Tf)
+//                                        + (thread_capacity_remaining * 115 / 100) // tempo de execução da (Tf)
+//                                        + eet_remaining                           // tempo de execução (Ti)
+//                                        + rp_waiting_time;                        // tempo de espera por RP (Ti)
+
+//             if (total_time_execution < int(Time_Base(_personal_statistics.remaining_deadline))) {
+//                 t_fitted = thread_in_queue;
+//                 // vai inserir na frente de alguem, entao salvar onde
+//                 _behind_of = t_fitted;
+//                 db<GEAMQ>(TRC) << "Encontrou um lugar atrás de: " << t_fitted << endl;
+//                 break;
+//             }
+//         }
+
+//         // Não permitimos inserir threads na primeira posição da fila se alguma já tiver sido inserida
+//         // Se não encontrou nenhuma fila (não vazia) que cabe a thread (e tem threads periodicas) avalie a próxima
+//         if (!t_fitted && !Thread::scheduler()->empty(i) && Thread::scheduler()->head(i)->object()->criterion().periodic()) {
+//             db<GEAMQ>(TRC) << "Thread não cabe na fila " << i << endl;
+//             continue;
+//         }
+
+//         // forma de accesar a cabeça e checar se é periodica
+//         // Thread::scheduler()->head(i)->object()->criterion().periodic()
+
+//         // Se a fila estiver vazia t_fitted = NULL
+//         int t_fitted_capacity_remaining = 0;
+
+//         /////////////////////// P3TEST - Se tem thread ja sendo executado por Cores nessa fila ///////////////////////
+//         if (Thread::scheduler()->empty(i) && (Thread::scheduler()->chosen_now(i))) {
+//             t_fitted = Thread::scheduler()->chosen_now(i)->object();
+//             db<GEAMQ>(TRC) << "Fila vazia mas já existe um chosen para esse core nela" << endl;
+//         }
+
+//         // Se a fila não estiver vazia precisamos levar em consideração o tempo que a thread da frente esperará
+//         // if (!Thread::scheduler()->empty(i) && Thread::scheduler()->head(i)->object()->criterion().periodic() ) {
+//         if (t_fitted && Thread::scheduler()->head(i)->object()->criterion().periodic()) {
+//             db<GEAMQ>(TRC) << "Fila 'não vazia' e achou fila inserir!" << endl;
+//             t_fitted_capacity_remaining = t_fitted->criterion().personal_statistics().remaining_et[i];
+//         }
+
+//         // Calculo de slack
+//         // tempo de espera = tempo de espera por RP + tempo de espera da thread da frente + tempo de execução de thread da frente
+//         // tempo para execução = deadline - tempo de espera 
+//         // slack = tempo para execução - tempo de execução estimativa 
+//         int cwt_profile = rp_waiting_time + (t_fitted ? t_fitted->priority() + t_fitted_capacity_remaining : 0);
+//         int available_time_to_run = _personal_statistics.remaining_deadline - cwt_profile;
+//         int idle_time = available_time_to_run - eet_remaining;
+//         db<GEAMQ>(TRC) << "CWT: " << cwt_profile 
+//                         << ", Time to run: " << available_time_to_run 
+//                         << ", IDLE time: " << idle_time 
+//                         << endl;
+
+//         if (idle_time >= 0) {
+//             set_queue(i);
+//             _priority = cwt_profile;
+//             db<GEAMQ>(TRC) << "Thread inserted in queue " << i << " with priority " << cwt_profile << endl;
+//             db<GEAMQ>(TRC) << endl <<  endl;
+//             return 1;
+//         }
+//     }
+//     // Não encontrou lugar na fila
+//     // Rever com uma análise mais severa se vale a pena ainda tentar
+//     db<GEAMQ>(TRC) << "Não vai encaixar em nada, RODA EM POTENCIA MÁXIMA, talvez dê" << endl;
+//     db<GEAMQ>(TRC) << endl <<  endl;
+//     _priority = 0;
+//     set_queue(0);
+
+//     return 0;
+// }
+
 __END_SYS
diff --git a/src/api/semaphore.cc b/src/api/semaphore.cc
index 8783611..ea50555 100644
--- a/src/api/semaphore.cc
+++ b/src/api/semaphore.cc
@@ -18,9 +18,9 @@ Semaphore::~Semaphore()
 
 void Semaphore::p()
 {
-    db<Synchronizer>(TRC) << "Semaphore::p(this=" << this << ",value=" << _value << ")" << endl;
 
     begin_atomic();
+    db<Thread>(TRC) << "Semaphore::p(this=" << this << ",value=" << _value << ")" << endl;
     if(fdec(_value) < 1)
         sleep();
     end_atomic();
@@ -29,7 +29,7 @@ void Semaphore::p()
 
 void Semaphore::v()
 {
-    db<Synchronizer>(TRC) << "Semaphore::v(this=" << this << ",value=" << _value << ")" << endl;
+    db<Thread>(TRC) << "Semaphore::v(this=" << this << ",value=" << _value << ")" << endl;
 
     begin_atomic();
     if(finc(_value) < 0)
diff --git a/src/api/thread.cc b/src/api/thread.cc
index 5dfa94a..e2657f7 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -10,11 +10,10 @@ extern OStream kout;
 
 bool Thread::_not_booting;
 volatile unsigned int Thread::_thread_count;
-Scheduler_Timer * Thread::_timer;
+Scheduler_Timer *Thread::_timer;
 Scheduler<Thread> Thread::_scheduler;
 Spin Thread::_lock;
 
-
 void Thread::constructor_prologue(unsigned int stack_size)
 {
     lock();
@@ -25,37 +24,45 @@ void Thread::constructor_prologue(unsigned int stack_size)
     _stack = new (SYSTEM) char[stack_size];
 }
 
-
 void Thread::constructor_epilogue(Log_Addr entry, unsigned int stack_size)
 {
-    db<Thread>(TRC) << "Thread(entry=" << entry
+    db<GEAMQ>(TRC) << "Thread(entry=" << entry
                     << ",state=" << _state
                     << ",priority=" << _link.rank()
+                    << ",queue=" << _link.rank().queue()
                     << ",stack={b=" << reinterpret_cast<void *>(_stack)
                     << ",s=" << stack_size
                     << "},context={b=" << _context
-                    << "," << *_context << "}) => " << this << "@" << _link.rank().queue() << endl;
+                    << "," << *_context << "}) => " << _link.object() << "@" << _link.rank().queue() << endl;
 
     assert((_state != WAITING) && (_state != FINISHING)); // invalid states
 
-    if(_link.rank() != IDLE)
+    if (_link.rank() != IDLE)
         _task->enroll(this);
 
-    if((_state != READY) && (_state != RUNNING))
+    if ((_state != READY) && (_state != RUNNING)) {
+        db<Thread>(WRN) << "Thread not ready!" << endl;
         _scheduler.suspend(this);
+    }
 
     criterion().handle(Criterion::CREATE);
 
-    if(preemptive && (_state == READY) && (_link.rank() != IDLE))
+    if(preemptive && (_state == READY) && (_link.rank() != IDLE)) {
+        db<Thread>(WRN) << "Thread ready!" << endl;
         reschedule(_link.rank().queue());
+    }
 
     unlock();
 }
 
-
 Thread::~Thread()
 {
+    // ainda não consegui ver o destrutor funcionando nenhuma vez
+
+    db<PEAMQ>(WRN) << "Chamou o destrutor" << endl;
     lock();
+    db<PEAMQ>(WRN) << "Lockou no destrutor" << endl;
+
 
     db<Thread>(TRC) << "~Thread(this=" << this
                     << ",state=" << _state
@@ -67,8 +74,9 @@ Thread::~Thread()
     // The running thread cannot delete itself!
     assert(_state != RUNNING);
 
-    switch(_state) {
-    case RUNNING:  // For switch completion only: the running thread would have deleted itself! Stack wouldn't have been released!
+    switch (_state)
+    {
+    case RUNNING: // For switch completion only: the running thread would have deleted itself! Stack wouldn't have been released!
         exit(-1);
         break;
     case READY:
@@ -92,29 +100,32 @@ Thread::~Thread()
 
     _task->dismiss(this);
 
-    if(_joining)
+    if (_joining)
         _joining->resume();
 
     unlock();
+    db<PEAMQ>(WRN) << "Unlockou no destrutor" << endl;
 
     delete _stack;
 }
 
-
 void Thread::priority(Criterion c)
 {
     lock();
 
     db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
 
+    // P3 - Veriaveis novos
     unsigned long old_cpu = _link.rank().queue();
     unsigned long new_cpu = c.queue();
 
     if(_state != RUNNING) { // reorder the scheduling queue
         _scheduler.suspend(this);
+        // We dont throw the rerank event here because we are explicitly changing the priority
         _link.rank(c);
         _scheduler.resume(this);
-    } else
+    }
+    else
         _link.rank(c);
 
     if(preemptive) {
@@ -130,27 +141,29 @@ void Thread::priority(Criterion c)
     unlock();
 }
 
-
 int Thread::join()
 {
     lock();
 
-    db<Thread>(TRC) << "Thread::join(this=" << this << ",state=" << _state << ")" << endl;
-
+    db<Thread>(WRN) << "Thread::join(this=" << this << ",state=" << _state << ")" << endl;
     // Precondition: no Thread::self()->join()
     assert(running() != this);
 
     // Precondition: a single joiner
     assert(!_joining);
 
-    if(_state != FINISHING) {
-        Thread * prev = running();
+    if (_state != FINISHING)
+    {
+        Thread *prev = running();
 
         _joining = prev;
         prev->_state = SUSPENDED;
+        prev->criterion().handle(EAMQ::CHANGE_QUEUE);
         _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
+        // db<GEAMQ>(WRN) << "JOIN prev: " << prev << endl;
+        Thread *next = _scheduler.chosen();
 
-        Thread * next = _scheduler.chosen();
+        //db<PEAMQ>(WRN) << "PROXIMO THREAD: " << next->link() << endl;
 
         dispatch(prev, next);
     }
@@ -160,17 +173,19 @@ int Thread::join()
     return *reinterpret_cast<int *>(_stack);
 }
 
-
 void Thread::pass()
 {
     lock();
 
+    
     db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose(this);
+    Thread *prev = running();
+    // db<GEAMQ>(WRN) << "PASS prev: " << prev << endl;
+    prev->criterion().handle(EAMQ::CHANGE_QUEUE);
+    Thread *next = _scheduler.choose(this);
 
-    if(next)
+    if (next)
         dispatch(prev, next, false);
     else
         db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
@@ -178,67 +193,81 @@ void Thread::pass()
     unlock();
 }
 
-
 void Thread::suspend()
 {
     lock();
 
     db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
 
-    Thread * prev = running();
+    Thread *prev = running();
 
     _state = SUSPENDED;
+    // TODO: Throw a new event to recalculate rank from behind when the thread is suspend (removed)
     _scheduler.suspend(this);
 
-    Thread * next = _scheduler.chosen();
+    Thread *next = _scheduler.chosen();
 
     dispatch(prev, next);
 
     unlock();
 }
 
-
 void Thread::resume()
 {
     lock();
 
-    db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
+    db<GEAMQ>(TRC) << "Thread::resume(this=" << this << ") state= " << _state << endl;
 
-    if(_state == SUSPENDED) {
+    if (_state == SUSPENDED)
+    {
         _state = READY;
+        // Recalcular rank antes de voltar 
+        db<GEAMQ>(TRC) << "Calling handle" << endl;
+        this->criterion().handle(EAMQ::RESUME_THREAD);
+
+        db<GEAMQ>(TRC) << "Calling resume" << endl;
         _scheduler.resume(this);
 
-        if(preemptive)
+        if(preemptive) {
+            db<GEAMQ>(TRC) << "Calling reschedule" << endl;
             reschedule(_link.rank().queue());
+        }
     } else
-        db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
+        db<GEAMQ>(TRC) << "Resume called for unsuspended object!" << endl;
 
     unlock();
 }
 
-
 void Thread::yield()
 {
     lock();
 
     db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose_another();
+    Thread *prev = running();
+    // P4 - Acho que precisa disso 
+    prev->criterion().handle(EAMQ::CHANGE_QUEUE);
+    
+    Thread *next = _scheduler.choose_another();
 
     dispatch(prev, next);
 
     unlock();
 }
 
-
 void Thread::exit(int status)
 {
     lock();
+    // db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
+    Thread *prev = running();
+
+    // vejam remove() da lista, nós presumimos que a fila já está atualizada
+    // caso o chosen seja removido
+    // (na prática não há diferença alguma, pois ele será reinserido,
+    // anteriormente pensei que fosse corrigir o ultimo bug que falei no whats)
+    prev->criterion().handle(EAMQ::CHANGE_QUEUE);
 
-    Thread * prev = running();
     _scheduler.remove(prev);
     prev->_state = FINISHING;
     *reinterpret_cast<int *>(prev->_stack) = status;
@@ -246,57 +275,69 @@ void Thread::exit(int status)
 
     _thread_count--;
 
-    if(prev->_joining) {
+    if (prev->_joining)
+    {
         prev->_joining->_state = READY;
+        prev->_joining->criterion().handle(EAMQ::RESUME_THREAD);
         _scheduler.resume(prev->_joining);
         prev->_joining = 0;
     }
 
-    Thread * next = _scheduler.choose(); // at least idle will always be there
+    Thread *next = _scheduler.choose(); // at least idle will always be there
 
     dispatch(prev, next);
 
     unlock();
 }
 
-
-void Thread::sleep(Queue * q)
+void Thread::sleep(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::sleep(running=" << running() << ",q=" << q << ")" << endl;
-
     assert(locked()); // locking handled by caller
-
-    Thread * prev = running();
+    
+    Thread *prev = running();
+    prev->criterion().handle(EAMQ::CHANGE_QUEUE);
     _scheduler.suspend(prev);
     prev->_state = WAITING;
     prev->_waiting = q;
     q->insert(&prev->_link);
 
-    Thread * next = _scheduler.chosen();
+    Thread *next = _scheduler.chosen();
+    //db<PEAMQ>(WRN) << "PREV: " << prev->link() << ", NEXT: "<< next->link() << endl;
+    if (next == nullptr) {
+        db<GEAMQ>(WRN) << "TAMANHO DA FILA"<< GEAMQ::current_queue() << ": " << _scheduler.size(GEAMQ::current_queue())<< endl;
+    }
 
     dispatch(prev, next);
-}
 
+}
 
-void Thread::wakeup(Queue * q)
+void Thread::wakeup(Queue *q)
 {
-    db<Thread>(TRC) << "Thread::wakeup(running=" << running() << ",q=" << q << ")" << endl;
-
     assert(locked()); // locking handled by caller
 
-    if(!q->empty()) {
-        Thread * t = q->remove()->object();
+    if (!q->empty())
+    {
+
+        Thread *t = q->remove()->object();
+        
         t->_state = READY;
         t->_waiting = 0;
+
+
+        t->criterion().handle(EAMQ::RESUME_THREAD);
+
+        // TODO: Throw a new event to recalculate rank from behind when the thread is woken up
         _scheduler.resume(t);
 
-        if(preemptive)
+
+        if(preemptive) {
             reschedule(t->_link.rank().queue());
+
+        }
     }
 }
 
-
-void Thread::wakeup_all(Queue * q)
+void Thread::wakeup_all(Queue *q)
 {
     db<Thread>(TRC) << "Thread::wakeup_all(running=" << running() << ",q=" << q << ")" << endl;
 
@@ -313,6 +354,7 @@ void Thread::wakeup_all(Queue * q)
             cpus |= 1 << t->_link.rank().queue();
         }
 
+        // P3 - Alteração 
         if(preemptive) {
             for(unsigned long i = 0; i < Criterion::QUEUES; i++)
                 if(cpus & (1 << i))
@@ -321,17 +363,20 @@ void Thread::wakeup_all(Queue * q)
     }
 }
 
-
 void Thread::reschedule()
 {
-    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
+    if (!Criterion::timed || Traits<Thread>::hysterically_debugged)
         db<Thread>(TRC) << "Thread::reschedule()" << endl;
 
     assert(locked()); // locking handled by caller
 
-    Thread * prev = running();
-    Thread * next = _scheduler.choose();
-
+    Thread *prev = running();
+    //db<Thread>(WRN) << "Thread PREV: " << prev->link() << endl;
+    // Atualiza current_queue para proxima fila (next tem que ser thread da proxima fila)
+    db<PEAMQ>(WRN) << "RESCHEDULE prev: " << prev << endl;
+    prev->criterion().handle(EAMQ::CHANGE_QUEUE);
+    Thread *next = _scheduler.choose();
+    db<PEAMQ>(WRN) << "!!Thread NEXT: " << next << endl;    
     dispatch(prev, next);
 }
 
@@ -364,27 +409,28 @@ void Thread::time_slicer(IC::Interrupt_Id i)
     unlock();
 }
 
-
-void Thread::dispatch(Thread * prev, Thread * next, bool charge)
+void Thread::dispatch(Thread *prev, Thread *next, bool charge)
 {
     // "next" is not in the scheduler's queue anymore. It's already "chosen"
-
-    if(charge && Criterion::timed)
+    if (charge && Criterion::timed)
         _timer->restart();
 
-    if(prev != next) {
-        if(Criterion::dynamic) {
+    if (prev != next)
+    {
+        if (Criterion::dynamic)
+        {
             prev->criterion().handle(Criterion::CHARGE | Criterion::LEAVE);
             for_all_threads(Criterion::UPDATE);
-            next->criterion().handle(Criterion::AWARD  | Criterion::ENTER);
+            next->criterion().handle(Criterion::AWARD | Criterion::ENTER);
         }
 
-        if(prev->_state == RUNNING)
-            prev->_state = READY;
+        if (prev->_state == RUNNING) {
+            db<PEAMQ>(WRN) << "DEIXA READY" << endl;
+            prev->_state = READY;}
         next->_state = RUNNING;
 
-        db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
-        if(Traits<Thread>::debugged && Traits<Debug>::info) {
+        if (Traits<Thread>::debugged && Traits<Debug>::info)
+        {
             CPU::Context tmp;
             tmp.save();
             db<Thread>(INF) << "Thread::dispatch:prev={" << prev << ",ctx=" << tmp << "}" << endl;
@@ -402,15 +448,15 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
 
         if(smp)
             _lock.acquire();
+
     }
 }
 
-
 int Thread::idle()
 {
-    db<Thread>(TRC) << "Thread::idle(cpu=" << CPU::id() << ",this=" << running() << ")" << endl;
 
     while(_thread_count > CPU::cores()) { // someone else besides idles
+
         if(Traits<Thread>::trace_idle)
             db<Thread>(TRC) << "Thread::idle(cpu=" << CPU::id() << ",this=" << running() << ")" << endl;
 
@@ -418,7 +464,9 @@ int Thread::idle()
         CPU::halt();
 
         if(_scheduler.schedulables() > 0) // a thread might have been woken up by another CPU
+        {
             yield();
+        }
     }
 
     if(CPU::id() == CPU::BSP) {
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index a88ebe4..a423b1d 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -17,6 +17,9 @@ void Thread::init()
     if(smp && (CPU::id() == CPU::BSP))
         IC::int_vector(IC::INT_RESCHEDULER, rescheduler);  // if an eoi handler is needed, then it was already installed at IC::init()
 
+    // P3 - espera todos cores para não ativar interrupção de rescheduler
+    // antes de BSP configurar interrupção
+    CPU::smp_barrier();
 
     if(smp)
         IC::enable(IC::INT_RESCHEDULER);
@@ -29,14 +32,21 @@ void Thread::init()
         // If EPOS is a library, then adjust the application entry point to __epos_app_entry, which will directly call main().
         // In this case, _init will have already been called, before Init_Application to construct MAIN's global objects.
         Main * main = reinterpret_cast<Main *>(__epos_app_entry);
-
+        
         new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
-    }
-
+    } 
+    // P3 - outros cores precisa esperar BSP criar thread MAIN antes
+    if (CPU::id() != CPU::BSP)
+        CPU::smp_barrier();
 
+    // Timer reset dito pelo Leonardo
+    Timer::reset();
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
 
+    if (CPU::id() == CPU::BSP)
+        CPU::smp_barrier();
+
     // The installation of the scheduler timer handler does not need to be done after the
     // creation of threads, since the constructor won't call reschedule() which won't call
     // dispatch that could call timer->reset()
@@ -52,8 +62,9 @@ void Thread::init()
     CPU::smp_barrier();
 
     // Transition from CPU-based locking to thread-based locking
-    if(CPU::id() == CPU::BSP)
-        _not_booting = true;
+    // if(CPU::id() == CPU::BSP)
+    //     _not_booting = true;
+    _not_booting = true;
 }
 
 __END_SYS
diff --git a/src/init/init_application.cc b/src/init/init_application.cc
index 95f0e89..b49a6c6 100644
--- a/src/init/init_application.cc
+++ b/src/init/init_application.cc
@@ -31,7 +31,7 @@ public:
         if(Traits<System>::multiheap) { // heap in data segment arranged by SETUP
             db<Init>(INF) << endl;
             char * heap = (MMU::align_page(&_end) >= CPU::Log_Addr(Memory_Map::APP_DATA)) ? MMU::align_page(&_end) : CPU::Log_Addr(Memory_Map::APP_DATA); // ld is eliminating the data segment in some compilations, particularly for RISC-V, and placing _end in the code segment
-            Application::_heap = new (&Application::_preheap[0]) Application_Heap(heap, HEAP_SIZE);
+            Application::_heap = new (&Application::_preheap[0]) Heap(heap, HEAP_SIZE);
         } else {
             db<Init>(INF) << "adding all free memory to the unified system's heap!" << endl;
             for(unsigned int frames = MMU::allocable(); frames; frames = MMU::allocable())
diff --git a/src/init/init_end.cc b/src/init/init_end.cc
index cb40b94..0c7709f 100644
--- a/src/init/init_end.cc
+++ b/src/init/init_end.cc
@@ -16,6 +16,8 @@ public:
     Init_End() {
         db<Init>(TRC) << "Init_End()" << endl;
 
+        CPU::smp_barrier();
+
         if(!Traits<System>::multithread) {
             CPU::int_enable();
             return;
@@ -28,17 +30,20 @@ public:
         // It will return MAIN for CPU0 and IDLE for the others
         Thread * first = Thread::self();
 
-        db<Init, Thread>(INF) << "Dispatching the first thread: " << first << endl;
+        // db<Init, Thread>(INF) << "Dispatching the first thread: " << first << endl;
 
         // This barrier is particularly important, since afterwards the temporary stacks
         // and data structures established by SETUP and announced as "free memory" will indeed be
         // available to user threads.
+        CPU::smp_barrier();
 
         // Interrupts have been disabled at Thread::init() and will be reenabled by CPU::Context::load()
         // but we first reset the timer to avoid getting a time interrupt during load()
         if(Traits<Timer>::enabled)
             Timer::reset();
 
+        // Barreira dita pelo Leonardo
+        CPU::smp_barrier();
         first->_context->load();
     }
 };
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index 00e6b5f..c1ef90c 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -47,6 +47,8 @@ public:
 
         } else {
 
+            // P3 - Espera que BSP inicializa antes, e então outros cores inicializam
+            CPU::smp_barrier();
 
             db<Init>(INF) << "Initializing the CPU: " << endl;
             CPU::init();
diff --git a/src/machine/pc/pc_machine_init.cc b/src/machine/pc/pc_machine_init.cc
index b8d1716..50478f0 100644
--- a/src/machine/pc/pc_machine_init.cc
+++ b/src/machine/pc/pc_machine_init.cc
@@ -7,6 +7,12 @@ __BEGIN_SYS
 void Machine::pre_init(System_Info * si)
 {
 
+    // P3 - Sincroniza inicializacao da barreira
+    if (multicore) {
+        CPU::smp_barrier_init(si->bm.n_cpus);
+        CPU::smp_barrier();
+    }
+
     if(CPU::id() == CPU::BSP)
         Display::init();
 
diff --git a/src/setup/setup_legacy_pc.cc b/src/setup/setup_legacy_pc.cc
index be575a0..1cda4cf 100644
--- a/src/setup/setup_legacy_pc.cc
+++ b/src/setup/setup_legacy_pc.cc
@@ -189,6 +189,9 @@ Setup::Setup(char * boot_image)
 
     }
 
+    // P3 - Garantir que todos CPUs tenham inicializado paginação 
+    CPU::smp_barrier(si->bm.n_cpus);
+
     db<Setup>(INF) << "Setup::pc=" << CPU::pc() << endl;
     db<Setup>(INF) << "Setup::sp=" << CPU::sp() << endl;
     db<Setup>(INF) << "Setup::cr0=" << reinterpret_cast<void *>(CPU::cr0()) << endl;
diff --git a/src/utility/heap.cc b/src/utility/heap.cc
index 036f0e2..daada6c 100644
--- a/src/utility/heap.cc
+++ b/src/utility/heap.cc
@@ -4,7 +4,7 @@
 
 __BEGIN_UTIL
 
-void Heap::out_of_memory(unsigned long bytes)
+void Heap_Imp::out_of_memory(unsigned long bytes)
 {
     db<Heaps, System>(ERR) << "Heap::alloc(this=" << this << "): out of memory while allocating " << bytes << " bytes!" << endl;
 }
